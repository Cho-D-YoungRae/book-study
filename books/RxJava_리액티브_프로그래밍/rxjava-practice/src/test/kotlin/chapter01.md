# RxJava 의 기본

## 1.1 RxJava 와 리액티브 프로그래밍

### 1.1.1 RxJava 란

- 이벤트 처리와 같은 비동기 처리에 최적화
- Reactive Streams 사양을 구현
  - `Reactive Streams`: 어떤 라이브러리나 프레임워크라도 데이터 스트림을 비동기로 처리하는 공통 매커니즘을 인터페이스로 제공

### 1.1.2 리액티브 프로그래밍이란

- 리액티브 프로그래밍이란 필요한 데이터를 직접 가져와 처리하는 것이 아니라 보내온 데이터를 받은 시점에 반응해 이를 처리하는 프로그램을 만드는 것
- 부가가치세를 계산하는 프로그램을 생각할 때, 리스너를 이용하는 것과는 차이
  - 상품가격이 변동될 때 리스너가 반응하면서 강품가격에 해당하는 부가가치세를 다시 계산해 표시하는 것은 리액티브 프로그래밍 X
  - 리스너가 반응하면서 부가가치세 항목에 새로운 데이터가 전달되고 부가가치세 항목에서 계산 프로그램을 실행해 결과를 부가가치세로 표시한다면 리액티브 프로그래밍 O
- 리액티브 프로그래밍에서 데이터를 생산하는 측은 데이터를 전달하는 것까지 책임
  - 데이터를 소비하는 측이 전달받은 데이터로 무엇을 하는지는 몰라도 됨
  - 데이터를 생산하는 측은 데이터를 소비하는 측에서 무엇을 하든지 관계가 없으므로 소비하는 측의 처리를 기다릴 필요 X
  - 데이터를 통지한 후 데이터를 소비하는 측에서 데이터를 처리하는 도중이라도 데이터를 생산하는 측은 바로 다음 데이터를 처리할 수 있음

### 1.1.4 RxJava 의 특징

- 옵저버 패턴을 잘 확장
  - 옵저버 패턴: 감시 대상 객체의 상태가 변하면 이를 관찰하는 객체에 알려주는 구조
  - 옵저버 패턴에 완료와 에러 통지를 할 수 있어서 모든 데이터 통지가 끝나거나 에러가 발생하는 시점에 별도로 대응할 수도 있음
- 쉬운 비동기 처리
  - Reactive Streams 규칙의 근간이 되는 Observable 규약이라는 RxJava 개발 가이드라인을 따른 구현이라면 직접 스레드를 관리하는 번거로움에서 해방될 뿐만 아니라 구현도 간단하게 가능
- 동기 처리나 비동기 처리나 구현 방법에 큰 차이가 없음

## 1.2 Reactive Streams

### 1.2.1 Reactive Streams

- 라이브러리나 프레임워크에 상관없이 데이터 스트림을 비동기로 다룰 수 있는 공통 매커니즘

### 1.2.2 Reactive Streams 의 구성

- 데이터를 만들어 통지하는 `Publisher`
- 통지된 데이터를 받아 처리하는 `Subscriber`
- `Publisher` 가 데이터를 통지한 후 `Subscriber` 가 이 데이터를 받을 때까지의 데이터 흐름
  - `Publisher`는 통지 준비가 끝나면 이를 `Subscriber`에 통지(onSubscribe)
    - 해당 통지를 받은 `Subscriber`는 받고자 하는 데이터 개수를 요청
    - 이때 `Subscriber`가 자신이 통지 받을 데이터 개수를 요청하지 않으면 `Publisher`는 통지해야 할 데이터 개수 요청을 기다리게 되므로 통지를 시작할 수 없음
  - 그 다음 `Publisher`는 데이터를 만들어 `Subscriber`에 통지(onNext)
  - 이 데이터를 받은 `Subscriber`는 받은 데이터를 사용해 처리 작업을 수행
  - `Publisher`는 요청받은 만큼의 데이터를 통지한 뒤 `Subscriber` 로부터 다음 요청이 올 때까지 데이터 통지 중단
  - 이후 `Subscriber`가 처리 작업을 완료하면 다음에 받을 데이터 개수를 `Publisher`에 요청
    - 이 요청을 보내지 않으면 `Publisher`는 요청 대기 상태가 돼 `Subscriber`에 데이터를 통지할 수 없음
  - `Publisher`는 `Subscriber`에 모든 데이터를 통지하고 마지막으로 데이터 전송이 완료돼 정상종료 됐다고 통지(onComplete)
  - 완료 통지를 하고나면 `Publisher`는 이 구독 건에 대해 어떤 통지도 하지 않음
  - `Publisher`는 처리 도중에 에러가 발생하면 `Subscriber`에 발생한 에러 객체와 함께 에러를 통지(onError)

| 프로토콜        | 설명                  |
|-------------|---------------------|
| onSubscribe | 데이터 통지가 준비됐음을 알리는 통지 |
| onNext      | 데이터 통지              |
| onError     | 에러(이상 종료) 통지        |
| onComplete  | 완료(정상 종료) 통지        |

|인터페이스|설명|
|---|---|
|Publisher|데이터를 생성하고 통지하는 인터페이스|
|Subscriber|통지된 데이터를 전달받아 처리하는 인터페이스|
|Subscription|데이터 개수를 요청하고 구독을 해지하는 인터페이스|
|Processor|Publisher와 Subscriber의 기능이 모두 있는 인터페이스|

### 1.2.3 Reactive Streams 의 규칙

- 기본 규칙
  - 구독 시작 통지(onSubscribe)는 해당 구독에서 한 번만 발생
  - 통지는 순차적으로
  - null 을 통지하지 않음
  - Publisher 의 처리는 완료(onComplete) 또는 에러(onError)를 통지해 종료
- Subscription 의 메서드는 동기화된 상태로 호출. 즉, Subscription 의 메서드를 동시에 호출해서는 안됨
- RxJava 를 사용할 때는 각 통지 메서드와 Subscription 의 메서드를 호출할 때 동기화가 이뤄지므로 처리 자체가 스레드 안전한지는 특히 신경