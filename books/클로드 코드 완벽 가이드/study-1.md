# 클로드 코드 완벽 가이드 - 1회

## Chapter 01. 왜 클로드 코드인가?

에이전틱 AI를 다루는 개발자가 할 수 있어야 ㅌ는 것

- 방향 제시: AI가 올바른 방향으로 작업하도록 명확한 목표와 제약 조건 설정
- 비판적 검토: AI가 생성한 결과물의 품질, 보안, 아키텍처 정합성을 비판적으로 검토하고 개선 지시
- 최종 문제 해결: AI가 해결할 수 없는 복잡한 아키텍처 문제나 창의적인 해결책이 필요한 영역에 집중

클로드 코드 동작 방식

1. 프로젝트 시작 - 프로젝트 구조 분석
   1. 기존 코드베이스 탐색
   2. 사용 중인 프레임워크와 라이브러리 파악
   3. 코딩 스타일과 패턴 학습
2. 작업 계획 수립
   1. 필요한 컴포넌트 식별
   2. 구현 순서 결정
   3. 필요한 종속성 파악
3. 실행
   1. 파일 생성 및 수정
   2. 코드 작성
   3. 필요한 패키지 설치
   4. 테스트 코드 작성 및 실행
4. 검증 및 개선
   1. 작성한 코드 테스트
   2. 오류 발견 시 자동 수정
   3. 코딩 스타일과 패턴 학습

클로드 코드의 컨텍스트 이해

- 깊은 코드베이스 이해: 단순히 현재 파일만이 아닌, 전체 프로젝트 구조와 파일 간의 관계를 파악
- 암묵적 규칙 학습: 명시되지 않은 코딩 컨벤션이나 프로젝트 특유의 패턴을 자동으로 감지하고 따름
- 의존성 관계 추적: 코드 변경이 다른 부분에 미칠 영향을 사전에 파악하고 대응

클로드 코드의 능동적 문제 해결

- 선제적 버그 탐지: 코드를 작성하면서 잠재적 문제를 발견하고 즉시 수정
- 최적화 제안: 더 나은 알고리즘이나 패턴을 발견하면 능동적으로 제안
- 보안 취약점 경고: 보안 문제가 될 수 있는 코드를 작성하지 않으며, 기존 코드의 취약점도 지적

## Chapter 02. 요금제 알아보기

## Chapter 03. 클로드 코드 환경 설정

## Chapter 04. 클로드 코드 기본 인터페이스 이해하기

## Chapter 05. 슬래시 명령어 제대로 알아보기

- `/model`
  - 비용 최적화를 자동으로 하기 위해 Default 옵션은 좋은 선택
- `/compact`
  - 200k의 컨텍스트 윈도우
  - 해당 명령어로 지금까지의 컨텍스트 내용을 요약해서 중요한 내용만 컨텍스트로 남김
  - 200k 컨텍스트 윈도우가 꽉 찬다면 자동으로 `/compact` 실행하는 Auto Compact 기능 있으나, 다음 요청이 지금까지 요청과 현저히 다르거나 현재까지 중요한 내용이 잘 기억되면 좋을 것 같을 때에 직접 실행하는 것이 **추천** -> 의도하지 않게 실행되는 것을 방지
- `/config`
  - 기본 설정으로 사용해도 충분히 괜찮음
- `/permissions`
  - 클로드 코드가 자동으로 실행할 수 있는 기능을 정리해두는 기능
  - 프로젝트 단위 권한은 .claude/settings.local.json
  - 사용자 설정은 ~/.claude/settings.json
- `/memory`
  - ./CLAUDE.md: 프로젝트 단위 설정
  - ~/.claude/CLAUDE.md: 사용자 단위 설정
- `/mcp
  - 연결한 MCP를 관리하고 관련 명령어를 실행

## Chapter 06. CLAUDE.md 파일에 대한 모든 것

CLAUDE.md

- 클로드 코드는 이 파일을 읽어 프로젝트의 아키텍처, 코딩 규칙, 작업 절차 등을 깊이 있게 파악
- Stateless 한 LLM에게 프로젝트의 내용을 알려줄 수 있음

CLAUDE.md 작성 방법

- \#로 제목을 구분해서 제목별로 적당한 지시

CLAUDE.md 내용

- 클로드 코드의 컨텍스트 윈도우 크기는 현재 200k가 최대이므로 너무 많은 내용을 입력하면 클로그 코드가 실질적인 문제 해결에 쓸 컨텍스트 윈도우를 손해볼 수 있음
- 엔트로픽 권장
  - 자주 사용하는 bash 명령어
  - 핵심 파일 및 유틸 함수
  - 코드 스타일 가이드라인
  - 테스트 지침
  - 저장소 에티켓
    - 예: 브랜치 이름 지정, merge, rebase 등
  - 개발 환경 설정
    - 예: pyenv 사용, 작동하는 컴파일러 등
  - 프로젝트에 특정한 예상치 못한 동작이나 경고
  - 클로드 코드가 기억했으면 하는 기타 정보
- 저자 권장
  - 일괄적으로 사용하고 싶은 라이브러리에 대한 정보
  - 또는 아키텍처에 대한 정보

```md
# 사용할 기술 정리

- **테이블 제작할 때** 꼭 tanstack table 사용
- **폼 제작할 때** 꼭 tanstack form 사용

# 프로젝트 아키텍처

```text
app
├── (public)/        # 공개 라우트
│   ├── login/
│   ├── register/
│   └── profile/
├── admin/           # 어드민 대시보드
└── api/             # API 라우트
    ├── admin/v1/    # 어드민 API
    └── public/v1/   # 공개 API
```

CLAUDE.md 파일 종류

- 프로젝트 메모리(./CLAUDE.md)
  - 프로젝트 루트에 위치하며, 팀 전체에 적용할 규칙과 정보
  - 내용
    - 프로젝트 아키텍처: 프로젝트 구조와 핵심 구성 요소에 대한 상위 수준의 설명
    - 코딩 표준: 특정 스타일 가이드, 명명 규칙, 서식 규칙
    - 일반적인 워크플로: 애플리케이션 빌드, 테스트, 배포 지침
- 로컬 프로젝트 메모리(./CLAUDe.local.md)
  - 개인적인 프로젝트 관련 설정
  - 팀과 공유 X
  - 보통 .gitignore 에 추가
  - 내용
    - 샌드 박스 URL
    - 개인 API 키 또는 테스트 데이터
    - 자신에게 유용한 맞춤 명령어
- 사용자 메모리(~/.claude/CLAUDE.md)
  - 홈 디렉토리에 위치
  - 모든 프로젝트에 적용되는 전역 설정
  - 내용
    - 일반적인 코드 스타일 선호도
      - 예: 항상 2칸 들여쓰기 사용
    - 개인 도구를 위한 단축키

CLAUDE.md 관리

- 클로드 코드를 쓰면서 바로 수정하기
  - \# 키를 눌러 지시
    - 지시 내용이 CLAUDE.md 에 자동으로 통합
    - 자주 사용하길 권장
- IMPORTANT 나 YOU MUST 등 강조 표현을 사용하면 좋음
- CLAUDE.md 를 자주 다듬기
- 클로드 코드에게 주기적으로 관리하라고 하기
  - 예) 하나의 대화가 끝날 때마다 클로드 코드에 현재까지 대화 내용을 기반으로 CLAUDE.md 에 추가할 만한 내용을 추천해달라 하고, 내용을 확인한 다음 추가해달라고 함
  - `지금까지 대화를 기반으로 CLAUDE.md에 추가할 만한 내용을 추천해줘`
- 클로드 코드에게 파일 정리하라고 하기
  - 클로드가 CLAUDE.md 에 추가할 내용을 작업할 때는 현재 컨텍스트의 내용을 기준으로 작성하기 때문에 프로젝트 전반적인 관점에서는 필요하지 않은 애용이 과도하게 추가될 수 있음
  - 그렇게 되면 CLAUDE.md 가 과하게 커져서 컨텍스트가 낭비될 수 있기 때문에 가끔은 클로드 코드에 CLAUDE.md 를 정리해달라고 요청
  - `CLAUDE.md 파일이 너무 커지고 있는 것 같아. 프로젝트를 전반적으로 다시 이해하기 CLAUDE.md 에 필요 없는 내용은 삭제하고 과도한 내용은 축소하고 싶어. 수정된 내용을 추천해줘.`

클로드 코드가 CLAUDE.md 를 읽는 방식

- 현재 프로젝트 ㅜ이치에서 시작해 루트 디렉터리까지 거슬러 올라가며 발견하는 모든 CLAUDE.md, CLAUDE.local.md 파일을 읽음
- 하위 프로젝트에 있는 파일도 클로드 코드가 읽을 수 있지만 클로드 코드가 실행될 때 읽지 않고 클로드 코드가 작업을 하며 하위 폴더에 진입할 때 읽음
  - CLAUDE.md 로 컨텍스트를 과도하게 낭비하는 걸 방지하기 위함

## Chapter 07. 클로드 코드의 3가지 모드 알아보기

일반 모드

> 하나하나 확인하고 보고 싶을 때

- 기본 모드
- 클로드 수정 사항을 개발자가 가장 빠르게 받아볼 수 있는 모드
- 다음에서 유용
  - 새 라이브러리나 프레임워크를 도입하면서 기본 사용법을 익힐 때
  - 특정 로직을 구현하기 위한 다양한 알고리즘 아이디어를 얻고 싶을 때
  - 발생한 오류 메시지의 의미를 정확히 이해하고 싶을 때
  - 코드 리뷰 전 자신의 코드에 대한 제3자의 의견을 구하고 싶을 때
  - 아직 클로드 코드를 신뢰하지 못하여 하나씩 내가 컨트롤하고 싶을 때

자동 수정 모드

> 반복 작업에 유용

- 클로드 코드가 알아서 판단하고 알아서 코드를 수정
- 요구사항을 주면, 사용자에게 허락받지 않고 직접 코드를 수정
- `Shift + Tab` 으로 전환 -> `auto-accept edits on`
- 일반 모드보다 조심히 사용
  - 개발자와 클로드 코드의 의도가 일치하지 않을 수 있음
  - 컨텍스트 윈도우 제한을 넘기면 클로드 코드는 흐름을 잃음
- 추천되는 경우
  - 프로젝트 전반에 걸쳐 사용한 변수명, 함수명, 클래스명을 일괄 변경할 떄
  - 기존 코드를 최신 패턴이나 스타일 가이드에 맞도록 리팩터링 할 때
  - JSDoc 등 문서 작업을 할 때
  - 단순한 작업을 반복해서 해야 할 때
  - 테스트 코드를 작성해야 할 떄
- 작업 자체가 긴 컨텍스트가 필요 없거나, 단순 반복 작업, 명확한 PRD와 요구사항이 이미 잘 정리되어 있을 때 유용
- 특히 테스트 코드는 아무리 방대하더라도 프로젝트를 망치거나 하지 않으므로 자동 수정 모드와 궁합이 좋음
  - 자기 전에 테스트 코드를 실행하거나 점심을 먹으러 가기 전에 실행하는 방식으로 사용할 수 있음

플래닝 모드

> 가장 강력한 기능

- 코드를 작성하기 전에 설계도를 그리듯 소프트웨어의 구조와 개발 계획을 수립하는 단계에서 활용
- '새로운 사용자 인증 기능을 만들려고 하는데, 어떤 기술 스택을 사용하고 파일 구조는 어떻게 가져가야 할까?'와 같이 개방적이고 전략적인 질문을 던지면 클로드 코드는 체계적인 계획을 제시
- 가장 핵심적인 기능이고 가장 많이 오래 사용해야 하는 기능
- `Shift + Tab` 으로 전환 -> `plan mode on`
- 무언가 막연히 구현해야 할 기능이 있을 때는 일단 플래닝 모드로 진입
- 무조건 YES 누르지 말기
  - 첫 번째 플랜에 바로 실행(YES)하지 않는 것을 추천
  - 계획이 완벽해질 때까지 다듬어줘야 함
  - 중복되거나 잘못된 기술 선택, 과한 계획 등이 있을 경우 수정 필요
  - 나중에 구현하게 될 기능이라도 너무 큰 규모의 작업을 한 번에 하게 되면 컨텍스트 윈도우의 문제 발생
  - 계획이 너무 큰 경우 제어할 수 있는 범위 내에서 작업을 나눠 진행

## Chapter 08. 모델 선택, 사용량 관리 딱 알려드립니다!

Opus 와 Sonnect 의 **공통점**

- 하이브리드 추론 모드(Hybrid Reasoning Modes)
  - 두 모델 모두 두 가지 작동 모드 제공: 즉각적인 응답(Near-instant responses) 모드, 확장된 사고(Extended Thinking) 모드
- 병렬 도구 사용(Parallel Tool Use)
  - 웹 검색을 하거나 외부 API 호출 등 여러 도구를 동시에 사용할 수 있는 기능
- 향상된 지시 따르기 및 메모리(Enhanced Instruction Following and Memory)
  - 복잡하고 다단계로 이루어진 지시를 이전보다 훨씬 더 정확하게 따름
  - 개발자가 파일 접근 권한을 부여하면 시간이 지남에 따라 핵심 정보를 저장하고 암묵적인 지식을 구축하는 등 뛰어난 메모리 관리 능력
- 200k 토큰 컨텍스트 창
  - 약 15만 단어

Opus 와 Sonnect 의 **차이점**

> 단순히 더 좋은 모델이 아니라 듀얼 플래그십(Dual-Flagship)

- Claude Opus 4: 프런티어 전문가 모델
  - 엔트로픽의 기술력 정점에 있는 가장 지능이 높은 프런티어 모델
  - 고급 추론, R&D, 수 시간 동안 지속되는 정교하고 복잡한 에이전트 워크플로와 같은 현존하는 가장 어려운 과제를 해결하기 위해 설계
  - 비용보다 성능이 더 중요한 연구 및 개발 환경에 최적화
- Claude Sonnet 4: 고성능 엔터프라이즈 실무자
  - 지능, 속도, 비용의 균형을 최적으로 맞춘 모델
  - 코딩, 고객 대면 AI 에이전트, 대용량 처리 작업 등 실용적이고 확장 가능한 비즈니스 애플리케이션에 탁월한 성능을 발휘하도록 설계
  - 테스트 코드를 작성하거나 리팩터링할 때는 모델의 성능 보다는 얼마나 빠르게 대규모 작업을 처리하는지가 중요하므로 더 적합
  - 실용 코딩에서는 성능이 더 앞서기도 함

계획은 Opus, 빠른 코드 작성은 Sonnet

- Opus 모델이 전형적으로 Sonnet 모델보다 잘하는 작업은 추상적인 생각과 어려운 문제를 해결하는 것이므로 계획에는 Opus 모델이 압도적으로 유리
- 특히 한 번에 해결해야 하는 문제의 크기가 크고 요구사항이 복잡하면 복잡할수록 Opus 모델이 Sonnet보다 월등히 뛰어남
- 반면 계획이 명확하고 상세하면 Opus와 Sonnet의 성능에는 큰 차이 없음
  - Opus로 계획을 섬세하게 세운 다음, 계획을 이행할 때 Sonnet
- 잘 해결되지 않는 버그 및 에러를 해결하도록 요청할 때 Opus 를 사용하기도 함
  - Sonnet 도 잘 해결해주지만 여러 번 같은 에러가 반복되며 도저히 해결이 잘 안될 때 Opus에게 에러 메시지를 전달해주고 지금까지 어떤 시도를 했는지 알려주면 더욱 빠르게 문제의 핵심을 찾고 해결

## Chapter 09. 클로드 코드의 생각 과정 제어하기

CoT의 이해

- Cot(Chain of Thought)는 사고의 사슬, 논리적 사고 과정이라는 뜻의 프롬프팅 기법
- AI가 최종 답변을 내놓기 전에, 사고 과정을 명시적으로 기술하도록 유도
- 사용해야 하는 이유
  - 정확성: 수학, 논리 추론, 복합 분석 등 여러 단계를 거쳐야 하는 작업에서 발생할 수 있는 오류를 획기적으로 줄임
  - 일관성: 최종 결과물이 더욱 긴밀하고 체계적인 구성을 갖추도록 도움
  - 디버깅 용이성: 어떤 논리적 흐름으로 특정 결과에 도달했는지 투명하게 보여줌
- 모든 작업에 필요한 것은 아님
  - 응답 속도가 매우 중요하거나 작업 자체가 단순할 경우에는 오히려 비효율적일 수 있음

CoT 유도

- 프롬프트에 '생각해라'라는 문구만 포함하면 대체로 사고를 잘 해냄
- 사고와 답변을 분리하면 사고 과정을 더 자세히 확인할 수 있음
  - xml 태그로 thinking, answer 를 분리하여 답변하도록

확장된 사고

- 사고의 사슬(CoT)에서 한 단계 발전한 기능
- 모델이 확장된 사고를 사용하면 응답을 생성하는데 더 많은 노력을 들임 -> 사고 예산(Thinking Budget)
- '고민해라'라고 말하면 됨
  - `이 프로젝트에 테스트 코드를 작성하려고 하는데 프로젝트를 분석하고 고민한 다음 테스트 코드를 작성해줘`
- '고민해라'보다 '깊게 고민해라'가 더 오랜 사고를 유도하고, '더 깊게 고민해라'는 더욱 더 오랜 사고를 유도
  - `다루지 않은 에지 케이스에 대해 더욱 깊게 고민해줘`
- 한국어로 프롬프팅할 때 더욱 확실히 유도하려면 프롬프트의 앞에 원하는 생각 수준을 먼저 작성해주면 됨
  - `Think: 이 프로젝트에 필요한 보안 작업을 고민해줘`
  - `Think hard: 이 함수 테스트의 엣지 케이스들을 추가해줘`

|사고 명령어|설명|
|---|---|
|Think|기본 확장된 사고 유도|
|Think hard|강화된 확장된 사고 유도|
|Thkink harder|더욱 강화된 확장된 사고 유도|
|Ultra think|가장 강력한 확장된 사고 유도|

> 강력한 확장된 사고를 사용할 수록 사고 예산이 커지고 모델이 사용하는 토큰의 수와 응답 시간이 늘어나므로 처음에는 약한 강도의 사고를 유도하고 필요하다면 추가로 깊은 사고를 요청하는 것도 좋은 방법
