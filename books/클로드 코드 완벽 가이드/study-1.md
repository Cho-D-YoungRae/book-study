# 클로드 코드 완벽 가이드 - 1회

## Chapter 01. 왜 클로드 코드인가?

에이전틱 AI를 다루는 개발자가 할 수 있어야 ㅌ는 것

- 방향 제시: AI가 올바른 방향으로 작업하도록 명확한 목표와 제약 조건 설정
- 비판적 검토: AI가 생성한 결과물의 품질, 보안, 아키텍처 정합성을 비판적으로 검토하고 개선 지시
- 최종 문제 해결: AI가 해결할 수 없는 복잡한 아키텍처 문제나 창의적인 해결책이 필요한 영역에 집중

클로드 코드 동작 방식

1. 프로젝트 시작 - 프로젝트 구조 분석
   1. 기존 코드베이스 탐색
   2. 사용 중인 프레임워크와 라이브러리 파악
   3. 코딩 스타일과 패턴 학습
2. 작업 계획 수립
   1. 필요한 컴포넌트 식별
   2. 구현 순서 결정
   3. 필요한 종속성 파악
3. 실행
   1. 파일 생성 및 수정
   2. 코드 작성
   3. 필요한 패키지 설치
   4. 테스트 코드 작성 및 실행
4. 검증 및 개선
   1. 작성한 코드 테스트
   2. 오류 발견 시 자동 수정
   3. 코딩 스타일과 패턴 학습

클로드 코드의 컨텍스트 이해

- 깊은 코드베이스 이해: 단순히 현재 파일만이 아닌, 전체 프로젝트 구조와 파일 간의 관계를 파악
- 암묵적 규칙 학습: 명시되지 않은 코딩 컨벤션이나 프로젝트 특유의 패턴을 자동으로 감지하고 따름
- 의존성 관계 추적: 코드 변경이 다른 부분에 미칠 영향을 사전에 파악하고 대응

클로드 코드의 능동적 문제 해결

- 선제적 버그 탐지: 코드를 작성하면서 잠재적 문제를 발견하고 즉시 수정
- 최적화 제안: 더 나은 알고리즘이나 패턴을 발견하면 능동적으로 제안
- 보안 취약점 경고: 보안 문제가 될 수 있는 코드를 작성하지 않으며, 기존 코드의 취약점도 지적

## Chapter 02. 요금제 알아보기

## Chapter 03. 클로드 코드 환경 설정

## Chapter 04. 클로드 코드 기본 인터페이스 이해하기

## Chapter 05. 슬래시 명령어 제대로 알아보기

- `/model`
  - 비용 최적화를 자동으로 하기 위해 Default 옵션은 좋은 선택
- `/compact`
  - 200k의 컨텍스트 윈도우
  - 해당 명령어로 지금까지의 컨텍스트 내용을 요약해서 중요한 내용만 컨텍스트로 남김
  - 200k 컨텍스트 윈도우가 꽉 찬다면 자동으로 `/compact` 실행하는 Auto Compact 기능 있으나, 다음 요청이 지금까지 요청과 현저히 다르거나 현재까지 중요한 내용이 잘 기억되면 좋을 것 같을 때에 직접 실행하는 것이 **추천** -> 의도하지 않게 실행되는 것을 방지
- `/config`
  - 기본 설정으로 사용해도 충분히 괜찮음
- `/permissions`
  - 클로드 코드가 자동으로 실행할 수 있는 기능을 정리해두는 기능
  - 프로젝트 단위 권한은 .claude/settings.local.json
  - 사용자 설정은 ~/.claude/settings.json
- `/memory`
  - ./CLAUDE.md: 프로젝트 단위 설정
  - ~/.claude/CLAUDE.md: 사용자 단위 설정
- `/mcp
  - 연결한 MCP를 관리하고 관련 명령어를 실행

## Chapter 06. CLAUDE.md 파일에 대한 모든 것

CLAUDE.md

- 클로드 코드는 이 파일을 읽어 프로젝트의 아키텍처, 코딩 규칙, 작업 절차 등을 깊이 있게 파악
- Stateless 한 LLM에게 프로젝트의 내용을 알려줄 수 있음

CLAUDE.md 작성 방법

- \#로 제목을 구분해서 제목별로 적당한 지시

CLAUDE.md 내용

- 클로드 코드의 컨텍스트 윈도우 크기는 현재 200k가 최대이므로 너무 많은 내용을 입력하면 클로그 코드가 실질적인 문제 해결에 쓸 컨텍스트 윈도우를 손해볼 수 있음
- 엔트로픽 권장
  - 자주 사용하는 bash 명령어
  - 핵심 파일 및 유틸 함수
  - 코드 스타일 가이드라인
  - 테스트 지침
  - 저장소 에티켓
    - 예: 브랜치 이름 지정, merge, rebase 등
  - 개발 환경 설정
    - 예: pyenv 사용, 작동하는 컴파일러 등
  - 프로젝트에 특정한 예상치 못한 동작이나 경고
  - 클로드 코드가 기억했으면 하는 기타 정보
- 저자 권장
  - 일괄적으로 사용하고 싶은 라이브러리에 대한 정보
  - 또는 아키텍처에 대한 정보

```md
# 사용할 기술 정리

- **테이블 제작할 때** 꼭 tanstack table 사용
- **폼 제작할 때** 꼭 tanstack form 사용

# 프로젝트 아키텍처

```text
app
├── (public)/        # 공개 라우트
│   ├── login/
│   ├── register/
│   └── profile/
├── admin/           # 어드민 대시보드
└── api/             # API 라우트
    ├── admin/v1/    # 어드민 API
    └── public/v1/   # 공개 API
```

CLAUDE.md 파일 종류

- 프로젝트 메모리(./CLAUDE.md)
  - 프로젝트 루트에 위치하며, 팀 전체에 적용할 규칙과 정보
  - 내용
    - 프로젝트 아키텍처: 프로젝트 구조와 핵심 구성 요소에 대한 상위 수준의 설명
    - 코딩 표준: 특정 스타일 가이드, 명명 규칙, 서식 규칙
    - 일반적인 워크플로: 애플리케이션 빌드, 테스트, 배포 지침
- 로컬 프로젝트 메모리(./CLAUDe.local.md)
  - 개인적인 프로젝트 관련 설정
  - 팀과 공유 X
  - 보통 .gitignore 에 추가
  - 내용
    - 샌드 박스 URL
    - 개인 API 키 또는 테스트 데이터
    - 자신에게 유용한 맞춤 명령어
- 사용자 메모리(~/.claude/CLAUDE.md)
  - 홈 디렉토리에 위치
  - 모든 프로젝트에 적용되는 전역 설정
  - 내용
    - 일반적인 코드 스타일 선호도
      - 예: 항상 2칸 들여쓰기 사용
    - 개인 도구를 위한 단축키

CLAUDE.md 관리

- 클로드 코드를 쓰면서 바로 수정하기
  - \# 키를 눌러 지시
    - 지시 내용이 CLAUDE.md 에 자동으로 통합
    - 자주 사용하길 권장
- IMPORTANT 나 YOU MUST 등 강조 표현을 사용하면 좋음
- CLAUDE.md 를 자주 다듬기
- 클로드 코드에게 주기적으로 관리하라고 하기
  - 예) 하나의 대화가 끝날 때마다 클로드 코드에 현재까지 대화 내용을 기반으로 CLAUDE.md 에 추가할 만한 내용을 추천해달라 하고, 내용을 확인한 다음 추가해달라고 함
  - `지금까지 대화를 기반으로 CLAUDE.md에 추가할 만한 내용을 추천해줘`
- 클로드 코드에게 파일 정리하라고 하기
  - 클로드가 CLAUDE.md 에 추가할 내용을 작업할 때는 현재 컨텍스트의 내용을 기준으로 작성하기 때문에 프로젝트 전반적인 관점에서는 필요하지 않은 애용이 과도하게 추가될 수 있음
  - 그렇게 되면 CLAUDE.md 가 과하게 커져서 컨텍스트가 낭비될 수 있기 때문에 가끔은 클로드 코드에 CLAUDE.md 를 정리해달라고 요청
  - `CLAUDE.md 파일이 너무 커지고 있는 것 같아. 프로젝트를 전반적으로 다시 이해하기 CLAUDE.md 에 필요 없는 내용은 삭제하고 과도한 내용은 축소하고 싶어. 수정된 내용을 추천해줘.`

클로드 코드가 CLAUDE.md 를 읽는 방식

- 현재 프로젝트 ㅜ이치에서 시작해 루트 디렉터리까지 거슬러 올라가며 발견하는 모든 CLAUDE.md, CLAUDE.local.md 파일을 읽음
- 하위 프로젝트에 있는 파일도 클로드 코드가 읽을 수 있지만 클로드 코드가 실행될 때 읽지 않고 클로드 코드가 작업을 하며 하위 폴더에 진입할 때 읽음
  - CLAUDE.md 로 컨텍스트를 과도하게 낭비하는 걸 방지하기 위함

## Chapter 07. 클로드 코드의 3가지 모드 알아보기

일반 모드

> 하나하나 확인하고 보고 싶을 때

- 기본 모드
- 클로드 수정 사항을 개발자가 가장 빠르게 받아볼 수 있는 모드
- 다음에서 유용
  - 새 라이브러리나 프레임워크를 도입하면서 기본 사용법을 익힐 때
  - 특정 로직을 구현하기 위한 다양한 알고리즘 아이디어를 얻고 싶을 때
  - 발생한 오류 메시지의 의미를 정확히 이해하고 싶을 때
  - 코드 리뷰 전 자신의 코드에 대한 제3자의 의견을 구하고 싶을 때
  - 아직 클로드 코드를 신뢰하지 못하여 하나씩 내가 컨트롤하고 싶을 때

자동 수정 모드

> 반복 작업에 유용

- 클로드 코드가 알아서 판단하고 알아서 코드를 수정
- 요구사항을 주면, 사용자에게 허락받지 않고 직접 코드를 수정
- `Shift + Tab` 으로 전환 -> `auto-accept edits on`
- 일반 모드보다 조심히 사용
  - 개발자와 클로드 코드의 의도가 일치하지 않을 수 있음
  - 컨텍스트 윈도우 제한을 넘기면 클로드 코드는 흐름을 잃음
- 추천되는 경우
  - 프로젝트 전반에 걸쳐 사용한 변수명, 함수명, 클래스명을 일괄 변경할 떄
  - 기존 코드를 최신 패턴이나 스타일 가이드에 맞도록 리팩터링 할 때
  - JSDoc 등 문서 작업을 할 때
  - 단순한 작업을 반복해서 해야 할 때
  - 테스트 코드를 작성해야 할 떄
- 작업 자체가 긴 컨텍스트가 필요 없거나, 단순 반복 작업, 명확한 PRD와 요구사항이 이미 잘 정리되어 있을 때 유용
- 특히 테스트 코드는 아무리 방대하더라도 프로젝트를 망치거나 하지 않으므로 자동 수정 모드와 궁합이 좋음
  - 자기 전에 테스트 코드를 실행하거나 점심을 먹으러 가기 전에 실행하는 방식으로 사용할 수 있음

플래닝 모드

> 가장 강력한 기능

- 코드를 작성하기 전에 설계도를 그리듯 소프트웨어의 구조와 개발 계획을 수립하는 단계에서 활용
- '새로운 사용자 인증 기능을 만들려고 하는데, 어떤 기술 스택을 사용하고 파일 구조는 어떻게 가져가야 할까?'와 같이 개방적이고 전략적인 질문을 던지면 클로드 코드는 체계적인 계획을 제시
- 가장 핵심적인 기능이고 가장 많이 오래 사용해야 하는 기능
- `Shift + Tab` 으로 전환 -> `plan mode on`
- 무언가 막연히 구현해야 할 기능이 있을 때는 일단 플래닝 모드로 진입
- 무조건 YES 누르지 말기
  - 첫 번째 플랜에 바로 실행(YES)하지 않는 것을 추천
  - 계획이 완벽해질 때까지 다듬어줘야 함
  - 중복되거나 잘못된 기술 선택, 과한 계획 등이 있을 경우 수정 필요
  - 나중에 구현하게 될 기능이라도 너무 큰 규모의 작업을 한 번에 하게 되면 컨텍스트 윈도우의 문제 발생
  - 계획이 너무 큰 경우 제어할 수 있는 범위 내에서 작업을 나눠 진행

## Chapter 08. 모델 선택, 사용량 관리 딱 알려드립니다!

Opus 와 Sonnect 의 **공통점**

- 하이브리드 추론 모드(Hybrid Reasoning Modes)
  - 두 모델 모두 두 가지 작동 모드 제공: 즉각적인 응답(Near-instant responses) 모드, 확장된 사고(Extended Thinking) 모드
- 병렬 도구 사용(Parallel Tool Use)
  - 웹 검색을 하거나 외부 API 호출 등 여러 도구를 동시에 사용할 수 있는 기능
- 향상된 지시 따르기 및 메모리(Enhanced Instruction Following and Memory)
  - 복잡하고 다단계로 이루어진 지시를 이전보다 훨씬 더 정확하게 따름
  - 개발자가 파일 접근 권한을 부여하면 시간이 지남에 따라 핵심 정보를 저장하고 암묵적인 지식을 구축하는 등 뛰어난 메모리 관리 능력
- 200k 토큰 컨텍스트 창
  - 약 15만 단어

Opus 와 Sonnect 의 **차이점**

> 단순히 더 좋은 모델이 아니라 듀얼 플래그십(Dual-Flagship)

- Claude Opus 4: 프런티어 전문가 모델
  - 엔트로픽의 기술력 정점에 있는 가장 지능이 높은 프런티어 모델
  - 고급 추론, R&D, 수 시간 동안 지속되는 정교하고 복잡한 에이전트 워크플로와 같은 현존하는 가장 어려운 과제를 해결하기 위해 설계
  - 비용보다 성능이 더 중요한 연구 및 개발 환경에 최적화
- Claude Sonnet 4: 고성능 엔터프라이즈 실무자
  - 지능, 속도, 비용의 균형을 최적으로 맞춘 모델
  - 코딩, 고객 대면 AI 에이전트, 대용량 처리 작업 등 실용적이고 확장 가능한 비즈니스 애플리케이션에 탁월한 성능을 발휘하도록 설계
  - 테스트 코드를 작성하거나 리팩터링할 때는 모델의 성능 보다는 얼마나 빠르게 대규모 작업을 처리하는지가 중요하므로 더 적합
  - 실용 코딩에서는 성능이 더 앞서기도 함

계획은 Opus, 빠른 코드 작성은 Sonnet

- Opus 모델이 전형적으로 Sonnet 모델보다 잘하는 작업은 추상적인 생각과 어려운 문제를 해결하는 것이므로 계획에는 Opus 모델이 압도적으로 유리
- 특히 한 번에 해결해야 하는 문제의 크기가 크고 요구사항이 복잡하면 복잡할수록 Opus 모델이 Sonnet보다 월등히 뛰어남
- 반면 계획이 명확하고 상세하면 Opus와 Sonnet의 성능에는 큰 차이 없음
  - Opus로 계획을 섬세하게 세운 다음, 계획을 이행할 때 Sonnet
- 잘 해결되지 않는 버그 및 에러를 해결하도록 요청할 때 Opus 를 사용하기도 함
  - Sonnet 도 잘 해결해주지만 여러 번 같은 에러가 반복되며 도저히 해결이 잘 안될 때 Opus에게 에러 메시지를 전달해주고 지금까지 어떤 시도를 했는지 알려주면 더욱 빠르게 문제의 핵심을 찾고 해결

## Chapter 09. 클로드 코드의 생각 과정 제어하기

CoT의 이해

- Cot(Chain of Thought)는 사고의 사슬, 논리적 사고 과정이라는 뜻의 프롬프팅 기법
- AI가 최종 답변을 내놓기 전에, 사고 과정을 명시적으로 기술하도록 유도
- 사용해야 하는 이유
  - 정확성: 수학, 논리 추론, 복합 분석 등 여러 단계를 거쳐야 하는 작업에서 발생할 수 있는 오류를 획기적으로 줄임
  - 일관성: 최종 결과물이 더욱 긴밀하고 체계적인 구성을 갖추도록 도움
  - 디버깅 용이성: 어떤 논리적 흐름으로 특정 결과에 도달했는지 투명하게 보여줌
- 모든 작업에 필요한 것은 아님
  - 응답 속도가 매우 중요하거나 작업 자체가 단순할 경우에는 오히려 비효율적일 수 있음

CoT 유도

- 프롬프트에 '생각해라'라는 문구만 포함하면 대체로 사고를 잘 해냄
- 사고와 답변을 분리하면 사고 과정을 더 자세히 확인할 수 있음
  - xml 태그로 thinking, answer 를 분리하여 답변하도록

확장된 사고

- 사고의 사슬(CoT)에서 한 단계 발전한 기능
- 모델이 확장된 사고를 사용하면 응답을 생성하는데 더 많은 노력을 들임 -> 사고 예산(Thinking Budget)
- '고민해라'라고 말하면 됨
  - `이 프로젝트에 테스트 코드를 작성하려고 하는데 프로젝트를 분석하고 고민한 다음 테스트 코드를 작성해줘`
- '고민해라'보다 '깊게 고민해라'가 더 오랜 사고를 유도하고, '더 깊게 고민해라'는 더욱 더 오랜 사고를 유도
  - `다루지 않은 에지 케이스에 대해 더욱 깊게 고민해줘`
- 한국어로 프롬프팅할 때 더욱 확실히 유도하려면 프롬프트의 앞에 원하는 생각 수준을 먼저 작성해주면 됨
  - `Think: 이 프로젝트에 필요한 보안 작업을 고민해줘`
  - `Think hard: 이 함수 테스트의 엣지 케이스들을 추가해줘`

|사고 명령어|설명|
|---|---|
|Think|기본 확장된 사고 유도|
|Think hard|강화된 확장된 사고 유도|
|Thkink harder|더욱 강화된 확장된 사고 유도|
|Ultra think|가장 강력한 확장된 사고 유도|

> 강력한 확장된 사고를 사용할 수록 사고 예산이 커지고 모델이 사용하는 토큰의 수와 응답 시간이 늘어나므로 처음에는 약한 강도의 사고를 유도하고 필요하다면 추가로 깊은 사고를 요청하는 것도 좋은 방법

## Chapter 10. 커스텀 슬래시 커맨드 사용하기

커스텀 슬래시 커맨드 기본기

- 기본 슬래시 커맨드와 마찬가지로 '/'를 입력하여 사용 가능
- prefix, command-name, arguments 세가지 요소로 이루어져 있음

```sh
/<prefix>:<command-name> [arguments]
```

|파라미터|설명|
|\<prefix>|커스텀 커맨드의 스코프를 명시(예: 프로젝트 단위: project, 사용자 단위: user)|
|\<command-name>|커맨드가 정의된 마크다운 파일 이름(확장자는 제외하고 입력)|
|\[arguments]|커맨드에 제공할 선택적 매개변수. 매개변수로 issue-79처럼 실제 변수를 입력해도 되지만 프롬프트를 입력할 수도 있음. 클로드 코드가 스스로 어떻게 활용할지 판단|

커스텀 슬래시 커맨드 스코프

> CLAUDE.md 처럼 커스텀 슬래시 커맨드도 다양한 위치에 저장할 수 있음

- 프로젝트 커스텀 슬래시 커맨드
  - 위치:.claude/commands/
  - 프로젝트 단위로 적용
  - 프로젝트에 밀접하게 관련 있는 CI 실행, PRD 작성, 테스트 실행 및 구현 등
- 사용자 커스텀 슬래시 커맨드
  - 위치: ~/.claude/commands/
  - 개인적으로 자주 사용하는 커맨드
- 네임스페이싱
  - 프로젝트 네임스페이스 위치: .claude/commands/\<namespace>/\<command>.md
  - 사용자 네임스페이스 위치: ~/.claude/commands/\<namespace>/\<command>.md
  - 프로젝트 네임스페이스 prefix: \<namespace>:\<command>
  - 사용자 네임스페이스 prefix: \<namespace>:\<command>

커스텀 슬래시 커맨드 마크다운 파일 정의하기

- 자연어로 자유롭게 정의
- 다만 클로드가 조금 더 이해하기 쉽게 작성하는 방법
  - 마크다운 문법 사용
  - 제목은 '\#', 리스트는 '-' 사용
- 마크다운 프런트매터에 allowed-tools 와 description 속성을 사용하면 커맨드를 실행할 때 사용할도구, 커맨드, 커맨드에 대한 간략한 설명을 추가할 수 있음
- '!'를 사용해서 bash command를 명시하거나 '@'를 사용해서 파일을 참조할 수 있음

```md
---
allowed-tools: Bash(mkdir)
description: 하나의 디자인을 기반으로 여러 가지 독창적인 디자인 콘셉트를 병렬적으로 생성합니다.
---
# 디자인 콘셉트 병렬 생성기
이 커맨드는 제공된 단일 디자인을 바탕으로 다양한 관점과 스타일을 적용하여 여러 개의 독창적인 디자인 콘셉트를 동시에 생성합니다. 각 콘셉트는 고유한 특징과 접근 방식을 가지며, 사용자가 디자인 방향을 다각도로 검토하고 선택할 수 있도록 돕습니다.
---
# Prompt Instruction
현재 index.html의 디자인을 5개의 새로운 디자인으로 새로 제작해줘. 각각 design_concepts 폴더에 indes_1.html, index_2.html ... 현태로 새로 파일을 만들어 주고 파일별로 완전 새로운 디자인을 생성해줘. 각 디자인은 subagent가 담당할 수 있도록 해서 병렬로 작업해줘.
```

## Chapter 11. MCP 사용하기

> [youtube](https://www.youtube.com/watch?v=fPyX6G2Bh2g)

MCP(Model Context Protocol) 란?

- LLM이 데이터베이스, API, 파일 시스템과 같은 외부 도구 및 데이터 소스에 접근할 수 있도록 설계된 클라이언트-서버 구조의 개방형 프로토콜
- 데이터베이스 스키마를 질의하거나 API 문서를 참조하게 하고, 심지어 원격 서버의 이슈를 분석하는 등 고도로 확장된 작업을 수행 가능

MCP 서버 설정

- `claude mcp` 명령어를 사용하거나 .mcp.json 파일을 수정해서 추가 가능
- 서버는 로컬 프로세스로 실행되거나(stdio), 원격으로 접속(SSE, HTTP) 가능
- MCP는 대표적으로 세 가지 타입
  - 로컬 서버 방식(stdio)
  - SSE
  - HTTP
- 대부분의 MCP 서버는 로컬 서버 방식으로 MCP wprhd

로컬 서버 방식으로 MCP 추가

- 가장 기본적인 로컬 서버 방식(stdio)
- 클로드 코드가 사용자의 컴퓨터에서 직접 로컬 프로세스를 실행하고 해당 프로세스와 직접 통신하는 것을 의미

```sh
# 문법
claude mcp add <name> <command> [args...]

# 예제
claude mcp add context -- npx -y @upstash/context7-mcp
```

```json
{
   "mcpServers": {
      "context7": {
         "type": "stdio",
         "command": "npx",
         "args": [
            "-y",
            "@upstash/context7-mcp"
         ],
         "env": {}
      }
   }
}
```

SSE MCP 추가하기

```sh
# 문법
claude mcp add --transport sse <name> <command> [args...]

# 예제
claude mcp add --transport sse context7 https://mcp.context7.com/sse
```

```json
{
   "mcpServers": {
      "context7": {
         "type": "sse",
         "url": "https://mcp.context7.com/sse"
      }
   }
}
```

HTTP MCP 추가 하기

> MCP 에서는 스트리밍을 지원하는 HTTP 서버를 의미하는 경우가 많음

```sh
# 문법
claude mcp add --transport http <name> <command> [args...]

# 예제
claude mcp add --transport http context7 https://mcp.context7.com/sse
```

```json
{
   "mcpServers": {
      "context7": {
         "type": "http",
         "command": "npx",
         "args": [
            "-y",
            "@upstash/context7-mcp"
         ],
         "env": {}
      }
   }
}
```

MCP 연동이 잘 됐는지 확인하려면 `claude mcp list` 커맨드 사용

MCP 의 세 가지 전송 방식은 각각 다른 용도로 활용

- stdio 서버 방식
  - 가장 많이 사용되는 방식
  - 파이썬, bash 등 로컬 스크립트를 실행하기 때문에 네트워크 요청 필요 X
  - 로컬에서 실행되므로 지연 시간이 매우 낮음
  - 단순한 MCP 서버는 stdio 형태로 제공되는 경우가 많음
  - 하지만 직접 서버를 업데이트해야 하기 때문에 항상 최신 버전을 사용하고 있다고 장담할 수 없다는 단점
- SSE 서버와 HTTP 서버
  - MCP 서버를 호스팅하는 측에서 서버를 실행하고 있기 때문에 네트워크 요청이 오가야 함
  - 상대적으로 느리다는 단점
  - 별도의 업데이트 없이 항상 최신 버전의 응답을 받을 수 있을 거란 기대
  - MCP 서버를 구현할 때 더욱 다양한 기능을 제공할 수 있음

|구분|stdio 서버|SSE 서버|HTTP 서버|
|---|---|---|---|
|실행 위치|로컬 컴퓨터|원격 서버|원격 서버|
|통신 방향|양방향(프로세스 통신)|단방향(서버->클라이언트)|양방향(요청/응답)|
|연결 방식|프로세스 실행|지속적 연결|요청 기반 연결|
|핵심 용도|로컬 도구 및 스크립트 연동|실시간 데이터 스트리밍|일반적인 원격 API 연동|

유용한 MCP 리스트

|MCP 이름|기능|
|Postgresql, Mongodb, Mysql|데이터베이스에 접근할 수 있습니다. 실제 데이터베이스에 어떤 데이터가 있는지 조회하고 마이그레이션 계획을 짤 때 유용합니다.|
|Playwright, Puppeteer|MCP로 브라우저를 조종할 수 있습니다. 엔드투엔드 테스트를 하거나 크롤링할 때 유용합니다.|
|context7|각종 개발 도구의 가장 최근 공식 문서를 가져옵니다.|
|MagicUI|21st Dev의 아름다운 UI 컴포넌트들을 적용할 수 있습니다.|
|Github|깃허브, 깃 기능을 실행할 수 있습니다.|
|TossPayments, evenueCat|결제 관련 기능을 구현할 수 있습니다.|
|Supabase|Supabase에 연결할 수 있습니다.|

## Chapter 12. PRD와 실행 계획하기

PRD(Product Requirements Document)란?

- 무엇을, 왜 만들어야 하는지 정의하는 문서
- 기술적인 내용을 다룰 수 있지만 주목적은 아님
- PRD의 질문
  - 어떤 사용자를 위해서 만드는가?
  - 어떤 문제를 해결해주는가?
  - 비즈니스 측면에서 어떤 이득이 있는가?
  - 어떤 기능과 경험을 제공해야 하는가?
  - 사용자는 어떤 경험을 하게 되는가?
  - 우리는 무엇을(What), 왜(Why) 만드는가?
- 클로드도 이 문서로 사용자의 의도를 잘 파악할 수 있기 때문에 더 좋은 답변을 만들어냄

실행 계획(Execution Plan)이란?

- PRD를 구현하기 위한 계획을 작성한 문서
- PRD가 던져준 '무엇을'이라는 질문에 대해 '어떻게(How)', '언제까지(When)' 만들 것인지 명확하고 구체적인 기술의 언어로 정리
- 기술적인 디테일이 담김
  - 어떤 아키텍처를 쓸지
  - API 명세는 어떻게 할지
  - 데이터베이스 스키마는 어떻게 설계할지
  - 등 제품의 구현 방법을 구체적으로 정의
- AI 의 대표적인 약점이 컨텍스트 크기인데, 문제를 작게 쪼개면 작은 컨텍스트로 해결할 수 있음 -> 즉, 실행 계획은 큰 문제를 작고 명확하며 해결 가능한 문제로 분해하는 과정
- 실행 계획의 질문
  - 어떤 기술 스택을 사용할 것인가?
  - 아키텍처를 어떻게 구성할 것인가?
  - 데이터를 어떤 모델로 저장할 것인가?
  - 어떤 함수와 클래스를 작성할 것인가?
  - 어떤 작업을 먼저 수행할 것인가?

PRD 는 서비스의 오버뷰 성격을 띄기 때문에 디자인을 구현할 때 클로드가 함께 참고하도록 하면 개발자가 의도한 UX를 준수하는 데 큰 도움이 되고 실행 계획은 기능적인 요소를 클로드 코드에게 개발하도록 할 때 개발자의 의도를 벗어나는 걸 방지하고 명시한 기술을 명시한 스펙대로 정확히 개발할 때 매우 유용

클로드에게 실행 계획 작성을 요청하면 더 빨리 작업할 수 있음

- 작업 분해, 기술 명세, 의존성 파악, 산출물 및 일정 예측 순서로 태스크를 나눌 수 있도록 상세한 커스텀 커맨드 사용 가능
- explain_plan.md

```md
# 실행 계획 제작 커맨드
너는 지금부터 복잡한 개발 작업을 아규먼트로 받아서 독립적이고 관리 가능한 태스크로 분해하고 실행 계획을 작성하는 실행계획 설계 전문가야.

## 실행
작업은 아래 순서대로 실행해줘.
- 태스크 분석
- 태스크 분해
- 분해된 이슈 출력
- 사용자가 확인할 수 있도록 모든 분해된 이슈를 콘솔에 출력

## 핵심 목적
제시된 개발 태스크를 다음과 같이 변환하기
- 적절하게 태스크 분류 (백엔드/프런트엔드/풀스택/기타)
- 서로 독립적이고 영역을 침범하지 않는 태스크
- 서로에게 의존해야 한다면 "의존성"으로 해당 태스크 등록하기
- 200K 단일 컨택스트 내에 완료할 수 있는 분량의 태스크

## 실행 방법
### 태스크 분석 프로세스
[태스크 분석 프로세스 상세히 설명]
### 태스트 분해 프로세스
[태스크 분해 프로세스 상세히 설명]
### 분해된 이슈 출력 프로세스
[분해된 이슈를 어떤 포맷으로 출력해야 하는지 상세히 설명]
```

에이전틱 코딩을 한다면 실행 계획을 작성하는 과정에 가장 많은 시간을 할애해야 함

## Chapter 13. 에이전트 병렬로 실행하기

> [youtube](https://www.youtube.com/watch?v=0ZlDxNYdXf8)

서브에이전트

- 우리가 실행한 클로드 코드 에이전트가 작업을 위해 또 다른 에이전트를 생성해서 업무를 진행하는 것
- 서브에이전트는 병렬 또는 직렬로 실행할 수 있음
- 병렬 실행
  - 충돌이 발생하지 않도록 서로 독립적인 작업을 시키는 게 유리
  - 병렬 실행이 유리한 작업의 예
    - 다국어 작업할 떄 여러 언어로 동시에 병렬로 번역
    - 많은 분량의 테스트를 독립적으로 나눠서 동시에 병렬로 작업
    - 여러 디자인 시안을 동시에 병렬로 작업
    - 깃허브 이슈 여러 개를 동시에 생성

```md
# 역할

너는 지금부터 다국어 번역 전문가야. 웹사이트 홈페이지를 영어, 일본어, 중국어, 아랍어로 번역하는 걸 도와줘.

# 작업 순

- 번역해야할 텍스트를 전부 찾아줘
- 찾은 텍스트를 영어, 일본어, 중국어, 아랍어로 번역해줘.
- 각 언어별로 subagent 4개를 동시에 생성해서 동시에 평행으로(parallel) 작업해줘
- 번역 외에 다른 작업은 절대 하지 말아줘
- 모든 작업이 끝났다면 테스트, 린트, 빌드를 실행하고 에러가 없는지 확인해줘
```

직렬 실행

- 현대 AI 에이전틱 프로그래밍에서는 직렬 실행이 병렬 실행보다 훨씬 자주 사용됨
  - 콘텍스트 사이즈 때문
- 특히 대규모 작업을 진행할 때는 콘텍스트를 효율적으로 사용하는 게 매우 중요한데 이때 활용할 수 있는 기법이 서브에이전트를 직렬로 생성하는 방법
- 서브에이전트를 새로 생성하면 새로운 컨텍스트도 함께 생기는 것
- 메인에이전트는 워크플로 통제에 집중하고 실무는 서브에이전트에게 넘겨서 효율적인 작업을 할 수 있음
- 서브에이전트는 이전 작업에 대한 지식이 없으므로 명확하고 단순한 명령으로 독립적으로 작동하고 결과만 되돌려주도록 만들어야 함
- 예를 들어 CRUD 엔드포인트를 제작할 때 모든 작업을 하나의 에이전트에서 하기에는 어려우므로 작업을 여러 에이전트에게 나눠줘야 함
  - 클로드 코드는 이미 내부적으로 직렬 에이전트 기능을 사용 - `Task` 키워드
- 서브에이전트를 생성했을 때 작업이 진행되어도 메인에이전트의 토큰 사용량이 늘어나지 않음

커스텀 서브에이전트

> 각 작업에 최적화된 서브에이전트가 실행되도록 할 수 있음

커스텀 서브에이전트 생성

- `/agent` 커맨드 또는 직접 마크다운 파일을 생성하는 방식으로 만들 수 있음
- 엔트로픽에서는 우선 `/agent` 커맨드를 사용해서 커스텀 에이전트를 생성하고 마크다운 파일을 수정해나가는걸 추천

클로드 코드가 커스텀 서브에이전트를 사용하도록 하는 방법

- 클로드 코드가 자동으로 프롬프트를 분석하고 어떤 서브에이전트를 트리거할 지 정할 수 있도록 하는 방법
- 커스텀 에이전트의 이름을 프롬프트에 명확히 명시해서 해당 서브 에이전트를 무조건 사용할 수 있도록 하는 방법

커스텀 서브에이전트 사용 사례

- 테스트 에이전트
- 아키텍처 레이어별 에이전트
- 하면 안 되는 작업 명시하기

독립 에이전트

- 하나의 에이전트에서 Task를 전담하는 서브에이전트를 생성하는 방식과 달리 메인에이전트 자체를 여러 개 실행시키는 방법도 있음
- 클로드 코드를 여러 터미널 창에서 동시에 실행
- 사용 사례
  - 여러 프로젝트를 동시에 작업
  - 하나의 프로젝트의 여러 기능을 동시에 작업할 때

여러 프로젝트에 병렬로 에이전트 실행하기

- 여러 프로젝트에 클로드 코드를 동시에 실행하고 작업할 명령을 독립적으로 부여

Git Worktree 명령어 정리

- Git WorkTree 생성
  - 프로젝트 상위에 feature-1 이라는 폴더를 생성하고 현재 프로젝트와 똑같은 환경을 구현
  - 템플릿: `git worktree add [폴더 위치]`
  - 예제: `git worktree add ../feature-1`
- Git Worktree 생성하며 브랜치 이름 지정하기
  - -b 플래그를 추가하면 해당 브랜치 존재하지 않으면 생성
  - 템플릿: `git worktree add [폴더 위치] [브랜치 이름]`
  - 예제: `git worktree add ../feature-1 -b todo-1`
- Git Worktree 삭제하기
  - 작업이 끝났다면 워크트리 삭제 필요
  - Git Worktree 는 단순 폴더 개념이 아니기 때문에 직접 폴더를 삭제한다면 깃에는 여전히 워크트리 정보가 남아있게 됨
  - 템플릿: `git worktree remove [폴더 위치]`
  - 예제: `git worktree remove ../feature-1`
- Git Worktree 정리하기
  - 실수로 `remove`가 아니라 폴더 삭제로 워크트리를 정리했다면 폴더가 삭제되었더라도 깃에는 워크트리 정보가 그대로 남아있게 되는데 이때 prune 으로 정리 가능
  - `git worktree prune`

한 프로젝트에 병렬로 에이전트 실행하기

- Git Worktree 를 통해서 여러 워크스페이스를 생성
- 가장 먼저 해야 할 작업은 '작업을 어떻게 나눌 것인가'
- 이후 고려할 사항은 머지 컨플릭트
- 독립적인 작업을 했을 때 서로의 영역이 침범되지 않도록 충분히 격리된 형태로 작업을 나눠야 함

## Chapter 14. 깃허브 워크플로 사용하기

깃허브 연동하는 방법

- **깃허브 CLI** -> 엔트로픽 추천
- 깃허브 MCP

레이블 생성하기

- 효율적으로 깃허브 워크플로를 자동화하려면 적합한 레이블을 생성해야 함
- 개발 영역, 복잡도, 작업 유형으로 나누는 것 추천 -> 도메인까지 추가하면 더 좋음
- 레이블 장점
  - 여러 에이전트에게 병렬로 작업을 던져줄 때 서로 겹치지 않는지 한눈에 확인할 수 있음
  - 클로드 모델 선택의 기준

이전에는 깃허브 UI를 사용한 방법이 레이블을 가장 쉽게 생성하는 방법이었으나 이제는 클로드 코드로 한 번에 생성하는 게 훨씬 빠름

```sh
깃허브에 개발 영역(프론트엔드인지 백엔드인지 등), 복잡도(복잡, 보통, 쉬움), 작업 유형(도큐멘테이션, 기능, 테스트( 이런 레이블을 생성할 건데 깃허브 CLI를 어떻게 실행하면 될지 보여줘
```

이슈 생성하기

- 깃허브 워크플로를 생성할 때 가장 중요한 건 이슈를 생성하는 과정
- 실행 계획을 만드는 것처럼 해결하고 싶은 문제를 작은 태스크로 나누어 순서대로 생성하는 게 중요
- 이슈는 레이블을 명확히 달아줄수록 효율적
- 이 작업 역시 커스텀 커맨드를 활용해서 작업하면 매우 빠르게 할 수 있음
  - 깃허브 이슈에 어울릴만한 형태로 작업을 세분화해야 하기 때문에 어떤 형태로 이슈를 구성할지 지정해주는 게 좋음

이슈 작업하기

- 커스텀 커맨드로 독립적인 이슈를 해결하도록 함

병렬로 이슈 작업하기

- Git Worktree 를 생성하고 클로드 코드를 헤드리스로 생성하여 작업을 수행하는 것까지 하나의 스크립트로 만들어서 실행할 수 있다

## Chapter 15. 클로드로 아이디어 구체화하기

Playwright MCP

- 클로드 에이전트 뿐만 아니라 클로드 데스크톱을 함께 사용하면 컨텍스트를 효율적으로 나눠서 작업할 수 있음
- 클로드 코드는 프로젝트를 직접 수정할 떄만 사용하고 아이디어 정리나 PRD 작성 등 독립적으로 수행할 수 있는 작업은 따로 클로드 데스크톱에서 컨텍스트를 유지하는 것이 좋음
- AI 이전 시대에는 비슷한 느낌의 서비스를 기획하거나 웹사이트를 디자인하고 싶을 때 디자이너를 고용해서 와이어프레이밍과 목업을 했어야 했음
- AI 시대에는 영감을 얻고 싶은 대상이 명확하다면 Playerwright MCP 로 대상 서비스를 파악하고 필요한 정보를 수집할 수 있음

## Chapter 16. UI 프로토타이핑하기

클로드는 이미 대부분의 메이커 프레임워크를 잘 숙지하고 있기 때문에 어떤 프레임워크를 사용해도 상관없지만 프레임 워크를 선택할 때는 꼭 두 가지 요소를 고려해야 함

- 내가 어느 정도 알고 있는 프레임워크
  - 디버깅이 필요한 경우 있음
- 가장 인기 있고 대중적인 프레임워크를 선택할수록 좋은 결과를 얻을 가능성 높음

## Chapter 17. 인증 구현하기

> [youtube](https://www.youtube.com/watch?v=RsUjQ3U3UxM)

Supabase 워크플로는 로컬 Supabase 인스턴스를 실행해서 개발하다가 CI/CD 파이프라인을 통해서만 프로덕션 Supabase에 접근하는 걸 추천
