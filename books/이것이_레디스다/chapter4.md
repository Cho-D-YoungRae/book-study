# Chapter 4. 레디스 시작

[레디스 명령어 목록](http://redis.io/commands)

## 4.1 레디스와 데이터 구조

- 총 다섯 가지의 데이터형
  - 정렬된 셋은 셋 데이터형에 저장된 요소에 정렬기능이 추가된 구조이므로 3가지 데이터형과 문자열로 구분할 수 있음
- 단순함은 레디스의 가장 큰장점이자 단점
  - 잠점은 익히기 쉽고 직관적임
  - 단점은 저장된 데이터를 가공하는 방법에 제한이 있음
  - 레디스는 다양한 종류의 데이터형과 명령을 통해 단점 보완

## 4.2 레디스 데이터 구조와 명령어

> chapter2 의 정리내용 함께 참고

### 4.2.1 문자열 데이터

- 키 하나에 문자열 하나를 저장
- 저장 가능한 문자열 크기는 최대 512MB
- 인코딩된 문자열과 몇 가지 부가 정보가 포함된 구조체로 변환하여 저장하며 이것을 레디스 객체형이라고 부름

#### 문자열 데이터의 입력과 조회

- [mset 키 값 [키 값...]](https://redis.io/commands/mset/)
  - 키와 값의 쌍으로 이루어진 데이터를 저장
  - 처리 결과는 항상 성공
- [mget 키 [키...]](https://redis.io/commands/mget/)
  - mget 명령은 주어진 키에 대한 값의 목록 조회
  - 주어진 키가 존재하지 않을 때 해당 위치의 값이 (nil)로 표시

- [setnx 키 값](https://redis.io/commands/setnx/)
  - 데이터가 존재하면 저장하지 않음

- [msetnx 키 값 [키 값...]](https://redis.io/commands/msetnx/)
  - 저장하는 키 중 하나라도 존재하면 모두를 저장하지 않음

- [getset 키 값](https://redis.io/commands/getset/)
  - 입력된 값을 저장하고 이전에 저장된 값을 돌려줌
  - 존재하지 않는 킹 대하여는 주어진 값을 저장하고 결과로 nil을 돌려줌

#### 숫자의 증가와 감소

- 64비트 부호화 정수 signed integer로 표현할 수 있는 범위에서만 가능
- 내부적으로 시스템 종속적인 정수형을 가지지 않기 때문에 처리 겨로가는 32비트와 64비트 인스턴스에 관계없이 동일

- [incrby 키 값](https://redis.io/commands/incrby/)
  - 주어진 키에 저장된 숫자를 주어진 값만큼 증가
  - 값에 음수가 입력되면 감소
  - 키에 저장된 값이 숫자일 때만 수행
- [decrby 키 값](https://redis.io/commands/decrby/)
  - 주어진 키에 저장된 숫자를 주어진 값만큼 감소
  - 값에 음수가 입력되면 증가
  - 키에 저장된 값이 숫자일 때만 수행

#### 비트연산

- 비트연산을 통해 저장되는 문자열 데이터를 비트 단위로 처리할 수 있음
- 특정 사용자의 해당 일자 로그인 여부 등에 사용 가능
  - `setbit login:날짜 회원번호 1(로그인여부)`
  - `setbit login:20220905 1234 1`: 2022/09/05 에 회원번호 1234 로그인 했음

- [setbit 키 오프셋 값](https://redis.io/commands/setbit/)
  - 주어진 키에 저장된 값에 대한 처리. 즉, 입력된 오프셋 위치에 저장된 bit값 변경
- [getbit 키 오프셋](https://redis.io/commands/getbit/)
  - 입력된 오프셋 위치에 저장된 bit 값을 조회
  - 주어진 키가 존재하지 않거나 주어진 오프셋에 해당하는 값이 없을 때는 0을 반환
- [strlen 키](https://redis.io/commands/strlen/)
  - 주어진 키에 저장된 문자열 길이 조회
  - 주어진 키가 존재하지 않으면 0 반환
  - 데이터 크기에 상관없이 항상 동일한 응답시간
- [bitcount 키 [시작인덱스] [종료인덱스]](https://redis.io/commands/bitcount/)
  - 주어진 키값의 비트 중 1인 값의 개수 조회
  - 인덱스 범위는 바이트 단위 인덱스

### 4.2.2 해시 데이터

- 문자열 필드와 값으로 이루어진 맵 구조

#### 그룹 데이터 저장

- [hmset 키 필드 값 [필드 값...]](https://redis.io/commands/hmset/)
  - 주어진 모든 필드와 값들을 저장
- [hsetnx 키 필드 값](https://redis.io/commands/hsetnx/)
  - 주어진 필드가 존재하지 않을 때 저장
- [hmget 키 필드 [필드...]](https://redis.io/commands/hmget/)
  - 주어진 키에서 주어진 필드 목록을 조회
- [hlen 키](https://redis.io/commands/hlen/)
  - 주어진 키에 저장된 필드의 개소 조회
- [hdel 키 필드 [필드...]](https://redis.io/commands/hdel/)
  - 주어진 키에 저장된 필드 제거

#### 숫자의 증감

- [hincrby 키 필드 지정값](https://redis.io/commands/hincrby/)
  - 주어진 키에 저장된 필드에 숫자 증감처리
  - 주어진 키가 존재하지 않으면 새로운 해시 데이터 생성
- [hincrbyfloat 키 필드 지정값](https://redis.io/commands/hincrbyfloat/)
  - 주어진 키에 저장된 필드에 숫자 증감처리
  - 지정값은 배정밀도 float값이어야 하며, 소수점은 17자리로 고정
  - 주어진 키가 존재하지 않으면 새로운 해시 데이터 생성

#### 해시 데이터의 키 목록 조회

- [hkeys 키](https://redis.io/commands/hkeys/)
  - 주어진 키에 저장된 모든 필드의 목록을 조회
- [hvals 키](https://redis.io/commands/hvals/)
  - 주어진 키에 저장된 모든 값에서 필드 이름을 제외한 값의 목록을 조회

### 4.2.4 셋 데이터

- 중복을 허용하지 않는 집합 형태의 자료구조
- 정렬되어 있지 않음
- 2^32-1 개의 값을 저장할 수 있음
- 값이 저장될 때 중복에 대한 확인이 일어나므로 NX 접미사의 명령 필요 없음
- 내부 구현은 해시 구조

#### 집합 연산

- 셋 데이터의 집합 연산은 명령 수행 비용이 매우 비싼 편이므로 반드시 필요한 상황에서만 사용

- [sinter 키 [키...]](https://redis.io/commands/sinter/)
  - 주어진 키에 저장된 요소들의 교집합 반환

#### 집합 요소 조회

- [scard 키](https://redis.io/commands/scard/)
  - 주어진 키에 저장된 요소들의 개수를 반환
  - 주어진 키가 존재하지 않으면 0 반환
- [srem 키 요소 [요소...]](https://redis.io/commands/srem/)
  - 주어진 키에 저장된 요소를 제거하고 제거된 요소의 개수를 반환
  - 주어진 키가 존재하지 않거나 해당 요소가 존재하지 않으면 0 반환
- [spop 키](https://redis.io/commands/spop/)
  - 주어진 키에 저장된 요소 중에서 임의의 요소를 제거하고 제거된 요소를 반환
  - 주어진 키가 존재하지 않으면 nil 반환
- [sismember 키 요소](https://redis.io/commands/sismember/)
  - 입력된 요소가 주어진 키에 저장되어 있는지 검사
  - 주어진 키가 존재하지 않으면 0반환
- [smove 원본키 대상키 요소](https://redis.io/commands/smove/)
  - 원본키에 저장된 요소를 대상키로 이동하고 이동결과 반환
  - 원본키가 존재하지 않으면 0반환
  - 대상 키가 존재하지 않으면 새로운 셋 데이터 생성 후 요소 이동

### 4.2.4 정렬된 셋 데이터

- 셋 데이터와 동일한 특징을 가지면서 요소 정렬이라는 부가적인 특징 가짐
- 정렬된 셋 명령의 접두사는 z
- 셋 데이터 구조에 요소의 가중치 값이 추가
  - 가중치에 따라 정렬
  - 기본 정렬 순서는 오름차순
- 가중치에 입력할 수 있는 값은 정수 또는 배정밀도 부동소수점

- [zrevrange 키 시작인덱스 종료인덱스 [withscores]](https://redis.io/commands/zrevrange/)
  - 주어진 키에 저장된 요소들의 내림차순 정렬 순서 범위에 해당하는 요소를 조회
  - zrange는 오름차순으로

#### 가중치 변경

- [zincrby 키 증감값 요소](https://redis.io/commands/zincrby/)
  - 주어진 키에 저장된 셋 데이터 중 지정된 요소의 가중치를 입력된 값만큼 증가
- [zrank 키 요소](https://redis.io/commands/zrank/)
  - 주어진 키에 저장된 셋 데이터 중 지정된 요소의 순위 조회
  - 조회되는 순위는 0부터 시작
  - 정렬은 가중치 오름차순
- [zrevrank 키 요소](https://redis.io/commands/zrevrank/)
  - 주어진 키에 저장된 셋 데이터 중 지정된 요소의 순위를 조회
  - 조회되는 순위는 0부터 싲가
  - 정렬은 가중치 내림차순

#### 순위 처리와 조회

- [zscore 키 값](https://redis.io/commands/zscore/)
  - 주어진 키에 저장된 셋 데이터 중 지정된 요소의 가중치 조회
- [zrevrangebyscore 키 최대가중치 최소가중치 [withscores] [limit '조회 결과 내의 위치' '조회할 건수']](https://redis.io/commands/zrevrangebyscore/)
  - 지정된 셋에 저장된 데이터의 가중치 범위에 해당하는 요소의 목록 조회

#### 정렬된 셋 명령의 특별한 표현식

- 정렬된 셋의 명렬 중 가중치를 인자로 사용하는 명령은 무한대 표현식과 초과/미만에 대한 표현식 사용 가능
  - 즉, 접미사가 score인 명령

### 4.2.5 리스트 데이터

- 저장 순서를 기억하는 데이터 구조로 중복 허용
- 저장 가능한 최대 요솟 수는 2^32-1개
- 이중 연결 리스트
- 내부적으로는 덱 데이터 구조를 구현

#### 스택 & 큐 연산

- [lindex 키 조회인덱스](https://redis.io/commands/lindex/)
  - 지정된 리스트에 저장된 요소의 인덱스에 해당하는 요소의 값을 조회
  - 해당 위치에 요소가 존재하지 않을 때 (nil) 반환
  - 키에 저장된 값이 리스트 데이터가 아닐 때 에러 출력
- [rpop 키](https://redis.io/commands/rpop/)
  - 지정된 리스트에 저장된 요소 중 맨 오른쪽의 요소를 조회
  - 저장된 데이터가 ㅇ벗거나 키가 존재하지 않을 때는 nil 반환
- [blpop 키 [키...] 만료시간](https://redis.io/commands/blpop/)
  - 지정된 리스트에 저장된 요소 중 맨 왼쪽 요소를 조회
  - 저장된 데이터가 없거나 키가 존재하지 않을 때는 만료시간에 지정된 시간만큼 대기 (단위: 초)
  - 지정된 만료시간이 0이면 무한히 대기
- [brpop 키 [키...] 만료시간](https://redis.io/commands/brpop/)
  - 지정된 리스트에 저장된 요소 중 맨 오른쪽 요소를 조회
  - 저장된 데이터가 없거나 키가 존재하지 않을 때는 만료시간에 지정된 시간만큼 대기 (단위: 초)
  - 지정된 만료시간이 0이면 무한히 대기

### 4.2.6 키 관리

- 레디스에 저장하는 키를 관리하는 명령
  - 삭제
  - 만료
  - 목록 조회
  - 직렬화
  - 역직렬화
  - 데이터형 조회
  - 이동

#### 키의 삭제와 변경, 만료

- [del 키 [키...]](https://redis.io/commands/del/)
  - 저장된 키와 데이터 삭제
  - 삭제된 키의 개수 반환
  - 키가 존재 하지 않으면 0반환
- [rename '변경할 키' '변결될 키'](https://redis.io/commands/rename/)
  - 주어진 키의 이름을 변경하고 변경 결과 반환
  - 변경할 키가 이미 존재하면 0
- [expire 키 만료시간](https://redis.io/commands/expire/)
  - 만료시간을 초 단위로 설정
  - 지정된 키가 존재하지 않거나 설정에 실패하면 0 반환
- [ttl 키](https://redis.io/commands/ttl/)
  - 지정된 키의 남은 만료시간을 초 단위로 조회
  - 만료시간이 지정되지 않았거나 키가 존재하지 않으면 -1 반환
- [exists 키](https://redis.io/commands/exists/)
  - 지정된 키가 존재하는지 검사
  - 존재하면 1, 존재하지 않으면 0
- [expireat 키 '유닉스 타임스탬프값'](https://redis.io/commands/expireat/)
  - 만료시간을 유닉스 타임스탬프 시간으로 설정
- [persist 키](https://redis.io/commands/persist/)
  - 키에 지정된 만료시간을 제거
  - 키가 존재하지 않거나 키에 지정된 만료시간이 없으면 0반환

#### 키 목록 조회

- [keys 조회할 패턴](https://redis.io/commands/keys/)

### 4.3 레디스 키 설계

> 레디스뿐만 아니라 여타 NoSQL의 설계시에도 동일하게 적용됨

- 키를 설계하는 방법
  - 관계형 데이터베이스의 스키마를 기본으로 하여 레디스의 저장구조로 바꾸는 방법
  - 화면에 출력될 데이터를 기준으로 하여 키를 설계하는 방법
  - 두가지 방법 모두 키에 부가적인 정보를 포함
- 키 설계가 완료된 시점에서 키는 조회조건, 값은 화면에 출력되는 내용
- 보통 NoSQL에서는 관계를 표현하기 위한 방법을 제공하지 않으며, 관계의 표현을 권장하지도 않음
  - 필요에 따라서 관계를 표현하기도 하는데, 이를 위한 방법으로 관계 정보를 키에 포함
