# Chapter 33. 파일 시스템

## 33-2 NIO.2 기반의 I/O 스트림 생성

```java
import java.io.InputStream;
import java.nio.file.Files;

Path fp = Paths.get("data.dat");
InputStream in = Files.newInputStream(fp);
```

```java
import java.io.InputStream;
import java.nio.file.Files;

Path fp = Paths.get("data.dat");
InputStream in = Files.newBufferedReader(fp);
```

## 33-3 NIO 기반의 입출력

> 자바의 입출력은 조금 느릴 수 밖에 없는 구조이다. 그래서 입출력의 성능을 개선한 NIO 패키지가 자바4에서 추가되었다.
> NIO 에서 제안하는 입출력 방법은 이전에 보인 방법과 많은 차이를 보인다. 따라서 다른 입출력 모델로 생각하고 접근할 필요가 있다.

- 다음 관점에서 스트림과 채널은 유사: 스트림도 채널도 데이터의 입력 및 출력의 통로가 된다
- 그러나 채널에는 다음 특징이 있다: 스트림은 한 방향으로만 데이터가 이동하지만채널은 양방향으로 데이터 이동이 가능하다
- 반면 채널은 다음과 같은 제약사항이 존재한다: 채널은 반드시 버퍼에 연결해서 사용해야 한다

### 성능 향상 포인트는 어디에?

효율적인 버퍼링

- 기존 IO 모델을 기반으로 파일 복사 프로그램을 작성하려면 입력 스트림과 출력 스트림 각각에 버퍼 스트림을 연결해야만 했다
  - 즉, 2 개의 버퍼가 필요했음
- 그리고 입력 버퍼에 저장된 데이터를 출력 버퍼로 이동하는 '버퍼 사이의 데이터 이동 과정'을 반드시 거쳐야 했음
- 그러나 이러한 작업을 NIO 모델에서는 생략 가능

```java
import java.nio.ByteBuffer;

ByteBuffer buf = ByteBuffer.allocate(1024);

ByteBuffer directBuf = ByteBuffer.allocateDirect(1024);
```

Direct 버퍼

- Non-Direct 버퍼로 분류할 수 있는 지금까지 소개된 모든 버퍼는 가상머신이 생성하고 유지하는 버퍼이다.
- 따라서 파일에 저장된 데이터를 읽어들일 때 다음의 흐름을 거쳐서 실행 중인 프로그램으로 데이터가 전달 된다.(운영체제도 입출력의 효율을 높이기 위해 나름의 버퍼를 유지한다.)
  - 파일 -> 운영체제 버퍼 -> 가상머신 버퍼 -> 실행 중인 자바 프로그램
- 반면 Direct 버퍼를 활용하면 이 과정이 다음과 같이 줄어든다
  - 파일 -> 운영체제 버퍼 -> 실행 중인 자바 프로그램
- 이렇듯 중간 과정 하나가 생략되므로 성능 향상을 기대할 수 있으나,
- Direct 버퍼의 할당과 해제에 드는 시간적 비용이 Non-Direct 버퍼에 비해 다소 높기 때문에 
- 입출력할 파일의 크기가 크지 않거나 버퍼를 빈번히 할당하고 해제해야 하는 상황이라면, 오히려 Non-direct 버퍼를 이용해서 입출력을 진행하는 것이 빠를 수 있다.

다양한 데이터의 입출력을 위해 `ByteBuffer` 이외에도 다음과 같이 기본 자료형 별로 버퍼 클래스가 정의되어 있다.

- `CharBuffer`, `IntBuffer`, `DoubleBuffer`, ...
- Direct 버퍼는 ByteBuffer 또는 그 하위 클래스를 대상으로만 생성 가능
- ByteBuffer 를 대상으로도 기본 자료형 데이터의 입출력이 가능하지만, '기본 자료형 배열'을 대상으로 입출력을 진해앟ㄹ 수 있도록 메서드가 정의되어 있다는 점에서 차이

### 파일 랜덤 접근

> 파일 랜덤 접근: 파일에 데이터를 쓰거나 읽을 때 원하는 위치에 쓰거나 읽는 것을 의미

- NIO 의 파일랜덤 접근은 버퍼를 기반으로 한다.
- 즉, 버퍼에 파일의 데이터를 옮겨 놓은 다음에, 버퍼에 저장된 데이터를 순서에 상관없이 원하는 순으로 읽어 들이는 방식
