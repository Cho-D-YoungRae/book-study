# Chapter 34. 쓰레드 그리고 동기화

## 32-1 쓰레드의 이해와 쓰레드의 생성

main 쓰레드가 일을 마쳤다고 해서 프로그램이 종료되지는 않는다. 모든 쓰레드가 일을 마치고 소멸되어야 프로그램이 종료된다.

쓰레드는 자신의 일을 마치면(run 메서드의 실행을 완료하면) 자동으로 소멸된다.

보통은 쓰레드 하나에 CPU 의 코어 하나가 할당되어 동시에 실행이 이뤄진다.

## 34-2 쓰레드의 동기화

```java
public final void join() throws InterruptedException
```

- 특정 쓰레드의 실행이 완료되기를 기다릴 때 호출하는 메서드

## 34-3 쓰레드를 생성하는 더 좋은 방법

### 지금 소개하는 이 방법으로 쓰레드를 생성하고 활용하자.

쓰레드의 생성과 소멸은 그 자체로 시스템에 부담을 주는 일이다.
따라서 처리해야 할 일이 있을 때마다 쓰레드를 생성하는 것은 성능 저하로 이어질 수 있다.
그래서 '쓰레드 풀(Thread Pool)' 이라는 것을 만들고 그 안에 미리 제한된 수의 쓰레드를 생성해 두고 이를 재활용하는 기술을 프로그래머들은 사용해 왔다.

처리해야 할 작업이 있을 때 풀에서 쓰레드를 꺼내 그 작업을 처맇하게 만든다.
그리고 작업을 끝낸 쓰레드는 다시 풀로 돌아가 다음 작업을 대기하게 된다.

`Executors` 클래스의 다음 메서드들을 통해서 다양한 유형의 쓰레드 풀을 생성할 수 있다

- `newSingleThreadExecutor`: 풀 안에 하나의 쓰레드만 생성하고 유지한다
  - 하나의 코어를 기준으로 코어의 활용도를 매우 높인 풀
  - 마지막에 전달된 작업은 가장 늦게 처리된다는 단점
- `newFixedThreadPool`: 풀 안에 지정된 수의 쓰레드를 생성하고 유지한다
- `newCachedThreadPool`: 풀 안의 쓰레드의 수를 작업의 수에 맞게 유동적으로 관리한다
  - 가장 효울적으로 쓰레드를 관리하는 것처럼 보일 수 있지만
  - 전달된 작업 수에 비례하여 쓰레드가 생성될 수 있는 관계로 앞서 언급한, 빈번한 쓰레드의 생성과 소멸로 이어질 수 있어서 주의 필요
- 생성된 쓰레드 풀과 그 안에 존재하는 쓰레드를 소명하기 위해서는 `shutdown` 메서드를 호출해야 함
  - 위 메서드가 호출되어도 이미 전달된 작업은 진행이 됨(추가로 작업을 전달받지는 않음)
  - 전달된 모든 작업이 처리가 되면 해당 풀은 종료

### Callable & Future

Runnable 인터페이스는 반환형이 void 이기 때문에 작업의 결과를 return 문을 통해 반환하는 것은 불가능 하다.
그러나 Callable 인터페이스를 기반으로 작업을 구성하면 작업의 끝에서 값을 반환하는 것이 가능하다.

반환 값은 `Future<V>` 으로 반환된다.

- `get` 메서드를 통해 쓰레드가 실행한 메서드의 반환값을 얻는다.
- 만약 위의 메서드를 호출한 시점에 쓰레드가 작업을 끝내지 않은 상태라면 해당 쓰레드가 값을 반환하고 작업을 끝낼 때까지 대기하게 된다.

### synchronized 를 대신하는 ReentrantLock

자바 5 에서는 동기화 블록과 동기화 메서드를 대신할 수 있는 `ReentrantLock` 클래스를 제공한다.

- finally 안에서 lock 반환하는게 좋음

### ExecutorService shutdown vs awaitTermination

- shutdown 메서드는 바로 반환됨
  - 즉, 쓰레드 풀에 전달된 작업이 마무리되면 풀을 폐쇄하라고 명령을 할 뿐 기다려 주지는 않음
- awaitTermination 메서드의 호출은 블로킹 상태에(반환하지 않은) 놓이게 되어, 다음 두 가지 중 한가지 상황에 이으러야 메서드를 빠져나오게 된다
  - 쓰레드 풀에 전달된 모든 작업이 완료되었다
  - 작업이 완료되지는 않았지만 초를 기준으로 100을 세었다
