# Chapter 11. OAuth 토큰

## 11.1 OAuth 토큰이 무엇인가?

- 토큰은 권한 위임 행위의 결과를 나타냄
- OAuth 핵심 스펙에서는 특성이나 위험 환경 그리고 요구 사항이 각기 다른 곳에 적용하기 위해 토큰을 구체적으로 정의하지 않음
- OAuth 토큰은
  - 유효 기간이 만료되거나 폐기될 수 있음
  - 유효 기간을 무기한으로 해 사용하거나 환경에 따라 다양한 조합을 사용할 수 있음
  - 시스템의 특정 사용자나 모든 사용자를 나타내거나 아무런 사용자도 나타내지 않을 수 있음
  - 내부 구조를 가지거나 임의의 값으로 만들어질 수 있음
  - 내용을 암호화해 보호할 수도 있고, 여러 가지 형태를 조합할 수도 있음

## 11.2 구조화된 토큰: JSON Web Token

### 11.2.1 JWT 의 구조

#### Base64 인코딩 하는 이유

- 사람이 읽을 수 없고 내용을 알기 위해서는 추가 처리 필요
- HTTP 헤더, 쿼리 파라미터, 폼 파라미터로 사용하거나 다양한 데이터베이스와 프로그래밍 언어에서 추가 인코딩 없이는 사용할 수 없는 경우가 많음
  - ie) {, } 문자를 각각 %7B %7D 로 인코딩 해야 함
- 미들웨어에서 추가 처리나 재직렬화가 대부분 필요 없어짐

## 11.3 암호화를 통한 토큰 보호

> JOSE(JSON Object Signing and Encryption): 서명을 위한 JWS(JSON Web Signatures) 와 암호화를 위한 JWE(JSON Web Encryption) 를 제공하며, 기본적인 데이터 모델로써 JSON 을 이용한 키 저장 포맷인 JWK(JSON Web Keys) fmf wprhd

### 11.3.1 HS 256 을 이용한 대칭 시그니처

- 공유된 시크릿을 이용해 인가 서버가 토큰을 서명하고 보호된 리소스에서는 공유된 시크릿을 이용해 서명된 토큰을 검증
- 인가 서버와 보호된 리소스가 밀접하게 연결돼있어서 API 키와 같은 것을 오랫동안 공유한다면 이 방법은 유용하겠지만, 인가 서버와 보호된 리소스 간의 직접적인 연결이 없는 경우에는 그렇지 않음

### 11.3.2 RS256 을 이용한 비대칭 시그니처

- 공유된 시크릿을 이용할 때 인가 서버와 리소스 서버는 시그니처를 생성하거나 검증하기 위해 동일한 시크릿 키를 사용해야 함
  - 인가 서버나 리소스 서버 중 누구나 토큰을 생성할 수 있다는 의미
- 시그니처는 RSA 알고리즘을 사용하기 때문에 더 길어짐

### 11.3.3 다른 토큰 보호 방법

- HS 256, 384, 512, RSA 256, 384, 512 큰 해시를 이용할 수록 그에 따라 토큰 시그니처도 더 커짐
- PS 256, 384, 512 지원
- 타원 곡선 지원
  - 시그니처의 크기가 상대적으로 작음
  - 검증을 위한 처리 리소스가 적게 듬

#### COSE 를 이용해보자

> COSE(CBOR Object Signing and Encryption) 라고 부르는 새로운 표준

- JOSE 와 동일한 기능 제공
- CBOR(Concise Binary Object Representation) 데이터 직렬화를 기반으로 함
  - 사람이 읽을 수 없는 형태의 바이너리 포맷
  - 기본적인 데이터 모델은 JSON 을 기반으로 하고 JSON 으로 표현되는 것이면 모두 CBOR 로 쉽게 변환할 수 있음
- JOSE 가 JSON 을 위한 것이라면, COSE 는 CBOR 을 위한 것

## 11.4 온라인으로 토큰의 정보를 조회: 토큰 인트로스펙션

- 토큰 자체에 토큰에 관한 정보를 포함시키는 **단점**
  - 토큰에 모든 요구된 클레임과 토큰을 보호하기 위해 필요한 암호화 구조를 포함시키면 토큰 자체가 상당히 커질 수 있음
  - 리소스 서버가 토큰 자체에 포함된 정보만 의지한다면 일단 생성되고 발급돼 사용되고 있는 토큰을 폐기시키는 것은 매우 어려워질 수 있음

### 11.4.1 인트로스펙션 프로토콜

> OAuth 토큰 인트로스펙션 프로토콜: 리소스 서버가 인가 서버에 토큰의 상태에 대한 질의를 적극적으로 수행하기 위핸 메커니즘 정의

- JWT 에서 정의한 것 외에 몇 가지 클레임을 추가로 정의: active, scope
- 토큰 인트로스펙션을 사용하면 OAuth 시스템상의 네트워크 트래픽이 증가
  - 이에 대한 대응 방법으로, 보호된 리소스는 토큰에 대한 인트로스펙션 결과를 캐시해 놓을 수 있음
  - 토큰이 캐시되는 동안 토큰이 폐기될 가능성을 제한하기 위해 캐시 유지 기간을 토큰의 유효기간보다 짧게 설정하는 것이 좋음

### 11.4.4 인트로스펙션과 JWT 의 결합

- 구조화된 토큰(JWT)와 토큰 인트로스펙션 중 어느 것 하나를 선택해야 하는 것처럼 보일 수 있지만, 사실 둘을 함께 사용하면 큰 효과를 볼 수 있음
- 만료 시간, 고유 식별, 발급자와 같은 핵심적인 정보는 JWT 로 전달
  - 토큰을 신뢰할 수 있는지 일차적으로 확인하기 위해 모든 리소스 서버가 필요한 것
- 그 다음에 리소스 서버는 인가된 사용자나 토큰을 발급받은 클라이언트 그리고 발급된 토큰의 권한 범위와 같은 토큰에 대한 보다 자세한(그리고 잠재적으로 민감한) 정보를 얻기 위해 토큰 인트로스펙션을 수행

#### 토큰의 상태

- 클라이언트에게는 토큰이 누군가에 의해 폐기됐는지 여부는 중요하지 않음
- 에러 응답의 내용이 토큰 폐기든, 토큰 만료든, 유효하지 않은 토큰이든 클라이언트의 응답은 항상 동일하기 떄문에 OAuth 프로토콘은 에러 응답을 따로 구별하지 않음
- 리소서 서버에게는 토큰이 폐기된 것인지를 아는 것이 매우 중요
- 폐기된 토큰을 받아들이면 거대한 보안 구멍이 생길 수 있음
- 리소스 서버가 로컬 데이터베이스를 검색하거나 실시간으로 인트로스펙션과 같은 질의를 수행한다면 토큰이 폐기된 것인지 쉽고 빠르게 알아낼 수 있음
- JWT 는 표면상으로는 독립적이기 때문에 상태가 없는 것으로 간주 -> 외부 신호를 이용하지 않고 리소스 서버에게 토큰이 폐기됐다는 것을 나타낼 수 있는 방법이 없음