# Chapter 04. 쿠버네티스를 이루는 컨테이너 도우미, 도커

## 4.1 도커를 알아야 하는 이유

쿠버네티스를 이루는 기본 오브젝트가 파드, 파드는 컨테이너로 이루어짐, 컨테이너를 만들고 관리하는 도구가 도커

### 4.1.1 파드, 컨테이너, 도커, 쿠버네티스의 관계

- 파드는 1개 이상의 컨테이너로 구성, 파드들은 워커 노드라는 단위로 관리, 워커 노드와 마스터 노드가 모여 쿠버네티스 클러스터
- 컨테이너를 돌보는 것이 파드, 파드를 돌보는 것이 쿠버네티스 워커 노드, 워커노드를 돌보는 것이 쿠버네티스 마스터
- 쿠버네티스 마스터 역시 파드(컨테이너)로 이루어짐
- `파드`
  - 쿠버네티스로부터 IP를 받아 컨테이너가 외부와 통신할 수 있는 경로 제공
  - 컨테이너들이 정상적으로 작동하는지 확인하고 네트워크나 저장 공간을 서로 공유하게 함
  - 컨테이너들은 마치 하나의 호스트에 존재하는 것처럼 작동
- `컨테이너`: 하나의 운영체제 안에서 커널을 공유하며 개별적인 실행환경을 제공하는 격리된 공간
  - 개별적인 실행 환경: CPU, 네트워크, 메모리와 같은 시스템 자원을 독자적으로 사용하도록 할당된 환경
  - 개별적인 실행 환경에서는 실행되는 프로세스를 구분하는 ID도 컨테이너 안에 격리돼 관리되므로 각 컨테이너 내부에서 실행되는 애플리케이션들은 서로 영향을 미치지 않고 독립적으로 작동할 수 있음
- `도커`
  - 컨테이너를 사용하는 방법을 명령어로 정리한 것
  - 사용자가 따로 신경쓰지 않아도 컨테이너를 생성할 때 개별적인 실행 환경을 분리하고 자원을 할당

## 4.2 도커로 컨테이너 다루기

### 4.2.1 컨테이너 이미지 알아보기

#### 이미지 검색하고 내려받기

- 이미지는 레지스트리(registry)라고 하는 저장소에 모여 있음
  - 도커 허브처럼 공개된 유명 레지스트리, 내부에 구축한 레지스트리 등...
- 하나의 이미지는 여러 개의 레이어로 구성
- `다이제스트(digest)`: 이미지의 고유 식별자로, 이미지에 포함된 내용과 이미지의 생성 환경을 식별
  - 식별자는 해시 함수로 생성되며 이미지가 동일한지 검증하는 데 사용
  - 이름이나 태그는 이미지를 생성할 때 임의로 지정하므로 이름이나 태그가 같다고 해서 같은 이미지라고 할 수 없음
  - 다이제스트는 고유한 값이므로 다이제스트가 같은 이미지는 이름이나 태그가 다르더라도 같은 이미지

#### 이미지 태그

> 이름이 동일한 이미지에 추가하는 식별자

- 이름이 동일해도 도커 이미지의 버전이나 플랫폼(CPU 종류나 기본 베이스를 이루는 운영 체제 등)이 다를 수 있기 때문에 이를 구분하는 데 사용
- 기본은 latest 태그
- 컨테이너를 배포할 때는 latest 태그가 아닌 검증된 버전으로 배포해야 문제가 생기지 않음

#### 이미지의 레이어 구조

- 이미지는 애플리케이션과 각종 파일을 담고 있다는 점에서 ZIP 같은 압출 파일로 볼 수 있음
- 이미지는 같은 내용일 경우 여러 이미지에 동일한 레이어를 공유하므로 용량을 효율적으로 사용 가능
- `docker history` : 컨테이너 이미지 자체를 만드는 명령을 보여줌

### 4.2.2 컨테이너 실행하기

- 컨테이너를 생성하면 컨테이너 고유 ID 반환
- `docker run`: 새로운 컨테이너 실행
  - `-d(--detach)`: 컨테이너를 백그라운드에서 구동
    - 옵션을 생략하면 컨테이너 내부에서 실행되는 애플리케이션의 상태가 화면에 계속 표시됨
    - 이 상태를 빠져 나오려고 Ctrl+C 를 누르면 애플리케이션 뿐만 아니라 컨테이너도 함께 중단
    - 계속 작동해야 하는 서버나 데이터베이스 같은 프로그램은 -d 옵션을 붙여 백드라운뎅서 작동하게 함
  - `--restart always`: 컨테이너의 재시작과 관련된 정책
    - 프로그램에 예상하지 못한 오류가 발생하거나 리눅스 시스템에서 도커 서비스가 중지되는 경우 컨테이너도 작동이 중지됨
    - 이때 중지된 컨테이너를 즉시 재시작하거나 리눅스 시스템에서 도커 서비스가 작동할 때 컨테이너를 자동으로 시작하도록 설정 가능
- `docker ps`: 생성한 컨테이너 상태 확인
  - `COMMAND`: 컨테이너가 생성될 때 내부에서 작동할 프로그램을 실행하는 명령어
  - `-f`: 검색 결과 필터링 옵션
    - id, name, label, exited, status, ancestor, ...
- 컨테이너는 변경 불가능한 인프라(immutable infrastructure)를 지향
  - 초기에 인프라를 구성하면 임의로 디렉터리 연결이나 포트 노출과 같은 설정르 변경 불가능
  - 컨테이너에 적용된 설정을 변경하려면 새로운 컨테이너를 생성해야 함
  - 이러한 특성 덕분에 컨테이너로 배포된 인프라는 배포된 상태를 유지한다는 장점
- 요청이 호스트에 도달한 후 컨테이너로 도달하기 위한 추가 경로 설정 필요
- `-p(--publish) <요청 받을 호스트 포트>:<연결할 컨테이너 포트>` : 외부에서 호스트로 보낸 요청을 컨테이너 내부로 전달
- 컨테이너 내부에서 웹 페이지 파일을 변경할 수 있지만 이런 경우, 컨테이너를 다시 생성하게 되면 매번 웹페이지 파일을 전송해야 함
- 그러므로 영속적으로 웹페이지 파일을 사용하기 위해서는 특정 디렉터리와 컨테이너 내부의 디렉터리를 연결하는 것이 효과적인 사용법

### 4.2.3 컨테이너 내부 파일 변경하기

- 도커 컨테이너 내부에서 컨테이너 외부 파일을 사용할 수 있는 방법
  - `docker cp <호스트 경로> <컨테이너 이름>:<컨테이너 내부 경로>`
    - 호스트에 위차한 파일을 구동중인 컨테이너 내부에 복사
  - `Dockerfile ADD`
    - 이미지에 컨테이너 내부로 복사할 파일 지정하면 이미지를 빌드할 때 지정한 파일이 이미지 내부로 복사
  - `바인드 마운트`
    - 호스트의 파일 시스템과 컨테이너 내부를 연결해 어느 한쪽에서 작업한 내용이 양쪽에 동시에 반영되는 방법
    - 호스트 디렉터리의 내용을 그대로 컨테이너 디렉터리에 덮어씀
    - 컨테이너 디렉터리에 어떠한 내용이 있더라도 해당 내용은 삭제됨
  - `볼륨`
    - 도커가 관리하는 볼륨을 컨테이너와 연결
    - 호스트의 파일 시스템과 컨테이너 내부를 연결하는 것은 바인드 마운트와 동일하지만, 호스트의 특정 디렉토리가 아님
    - 쿠버네티스의 볼륨 구조와 유사
    - 도커가 관리하는 볼륨 공간을 NFS와 같은 공유 디렉터리에 생성한다면 다른 호스트에서도 도커가 관리하는 볼륨을 사용 가능
    - 바인드 마운트와 달리 볼륨은 빈 디렉터리를 덮어쓰지 않고 컨테이너 내부에 있는 파일을 보존 (양쪽을 동기화)
      - 동일한 파일이 존재한 상태로 연결하는 경우에는 덮어쓰기

### 4.2.4 사용하지 않는 컨테이너 정리하기

- 컨테이너나 이미지를 삭제하기 전에 먼저 컨테이너를 정지
  - 동일한 호스트의 포트를 사용하는 컨테이너를 배포하거나 작동 중인 컨테이너의 사용 자체를 종료할 떄도 먼제 컨테이너를 정지
- `docker stop` : 컨테이너 정지

## 4.3 4가지 방법으로 컨테이너 이미지 만들기

### 4.3.1 기본 방법으로 빌드하기

- Dockerfile
  - `FROM <이미지 이름>:[태그]`
    - 이미지 가져옴
    - 가져온 이미지 내부에서 컨테이너 이미지 빌드
    - 누군가가 만들어 놓은 이미지에 필요한 부분 추가
  - `LABEL <레이블 이름>=<값>`
    - 이미지에 부가적인 설명을 위한 레이블을 추가할 때 사용
  - `EXPOSE <숫자>`
    - 생성된 이미지로 컨테이너를 구동할 때 어떤 포트를 사용하는지
    - 이를 사용한다고 해서 컨테이너를 구동할 때 자동으로 해당 포트를 호스트 포트와 연결하지는 않음
    - 외부와 연결하려면 지정한 포트를 호스트 포트와 연결해야 한다는 정보를 제공할 뿐
  - `COPY <호스트 경로> <컨테이너 경로>`
    - 호스트에서 새로 생성하는 컨테이너 이미지로 필요한 파일 복사
  - `RUN`
    - 이미지 생성할 때 실행되는 명령
  - `WORKDIR`
    - 이미지의 작업 위치 opt 로 변경
  - `ENTRYPOINT ["명령어", "옵션", ..., "옵션"]`
    - 컨테이너 구동 시 실행할 명령

### 4.3.2 컨테이너 용량 줄이기

- 기초 이미지를 openjdk에서 gcr.io/distroless/java 로 변경
- distroless 는 자바 실행을 위해 경량화된 이미지
- openjdk 이미지에 포함된 자바 개발 도구는 불필요하게 낭비되는 공간

### 4.3.3 컨테이너 내부에서 컨테이너 빌드하기

- `RUN` 명령을 이용해서 컨테이너 내부에서 빌드
- 컨테이너 내부에서 빌드를 진행하기 때문에 빌드 중간에 생성한 파일들과 내려받은 라이브러리 캐시들이 최종 이미지에 그대로 남음
- 컨테이너 이미지는 커지면 커질수록 비효율적으로 작동하므로 컨테이너 내부에서 컨테이너를 빌드하는 것은 좋지 않은 방법
- Dockerfile 하나만 빌드하면 컨테이너가 바로 생성되는 편리함

### 4.3.4 최적화해 컨테이너 빌드하기

- 최종 이미지 용량을 줄일 수 있고, 호스트에 어떠한 빌드 도구도 설치할 필요 없음
- 멀티 스테이지의 핵심은 빌드하는 위치와 최종 이미지를 **분리**하는 것
- 이미지 중 \<none> 으로 표시되는 이미지 생성될 수 있음
  - `댕글링(dangling)` 이미지
  - 멀티 스테이지 과정에서 자바 소스를 빌드하는 과정 중 생성된 이미지
  - 공간을 적게 사용하는 이미지를 만드는 것이 목적이므로 댕글링 이미지 삭제 (dangling=true)

```Dockerfile
FROM openjdk:8 AS int-build
LABEL description="Java Application builder"
RUN git clone https://github.com/iac-source/inbuilder.git
WORKDIR inbuilder
RUN chmod 700 mvnw
RUN ./mvnw clean package

FROM gcr.io/distroless/java:8
LABEL description="Echo IP Java Application"
EXPOSE 60434
COPY --from=int-build inbuilder/target/app-in-host.jar /opt/app-in-image.jar
WORKDIR /opt
ENTRYPOINT [ "java", "-jar", "app-in-image.jar" ]
```

## 4.4 쿠버네티스에서 직접 만든 컨테이너 사용하기

### 4.4.1 쿠버네티스에서 도커 이미지 구동하기

- 별도 설정이 없으면 기본 설정에 따라 이미지를 외부(도커 허브)에서 받으려고 시도
- 사용하려는 이미지를 로컬에서 가져오도록 설정하려면 모든 노드에 해당 컨테이너 이미지를 가지고 있어야함
  1. 기본으로 사용하는 도커 허브에 필요한 이미지를 올려서 내려받거나
  2. 쿠버네티스 클러스터가 접근할 수 있는 곳에 이미지 레지스트리를 만들고 그곳에서 받아오도록 설정

### 4.4.2 레지스트리 구성하기

- 이미지를 레지스트리에서 읽으려면 레지스트리가 서비스되는 주소(IP와 도메인)와 제공되는 이미지 이름을 레지스트리에 등록될 이름으로 지정해야 함
