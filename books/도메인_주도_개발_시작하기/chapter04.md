# Chapter 04. 리포지터리와 모델 구현

## 4.1 JPA 를 이용한 리포지터리 구현

### 4.1.1 모듈 위치

- 리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포티저리를 구혆나 클래스는 인프라스트럭처 영역에 속함
- 리포티저리 구현 클래스를 domain.impl 과 같은 패키지에 위치시킬 수도 있는데 이것은 리포지터리 인터페이스와 구현체를 분리하기 위한 타협안 같은 것이지 좋은 설계 원칙을 따르는 것은 아님

### 4.1.2 리포지터리 기본 기능 구현

- 리포지터리가 제공하는 기본 기능
  - ID 로 애그리거트 조회하기
  - 애그리거트 저장하기
- 인터페이스는 애그리거트 루트를 기준으로 작성

## 4.3 매핑 구현

### 4.3.1 엔티티와 밸류 기본 매핑 구현

- 루트 엔티티와 루트 엔터티에 속한 밸류(`@Embeddable`)는 한 테이블에 매핑할 때가 많음

### 4.3.2 기본 생성자

- 기본 생성자는 JPA 프로바이더가 객체를 생성할 때만 사용
- 다른 코드에서 기본생성자를 사용하지 못하도록 protected 로 선언

### 4.3.3 필드 접근 방식 사용

- 객체가 제공할 기능 중심으로 엔티티를 구현하게끔 유도하려면 JPA 매핑 처리를 프로퍼티 방식(`@Access(AccessType.PROPERTY`)이 아닌 필드 방식(`@Access(AccessType.FIELD)`)으로 선택해서 불필요한 get/set 메서드를 구현하지 않도록 해야 함
- `@Access` 를 이용해서 명시적으로 접근방식을 지정하지 않으면 `@Id` 나 `@EmbeddedId` 가 어디에 위치했느냐에 따라 접근 방식을 결정

### 4.3.4 `AttributeConverter` 를 이용한 밸류 매핑 처리

- 밸류 타입의 프로퍼티를 한 개 칼럼에 매핑해야 할 때 -> `AttributeConverter`
- `AttributeConverter` 는 밸류 타입과 칼럼 데이터 간의 변환을 처리
- `AttributeConverter` 인터페이스를 구현한 클래스는 `@Converter` 애너테이션 적용
  - `@Converter(autoApply = true)`: 해당되는 밸류 타입의 프로퍼티에 자동 적용
  - `@Converter(autoApply = false)`: 프로퍼티 값을 변환할 때 사용할 컨버터를 직접 지정해야 함
    - `@Converter(converter = MoneyConverter.class)` 를 해당 엔터티의 밸류 타입 필드에 지정

### 4.3.5 밸류 컬렉션: 별도 테이블 매핑

- 밸류 컬렉션을 별도 테이블로 매핑할 때는 `@ElementCollection` 과 `@CollectionTable` 을 함께 사용

### 4.3.6 밸류 컬렉션: 한 개 칼럼 매핑

- `AttributeConverter` 를 사용하면 밸류 컬렉션을 한 개 컬럼에 쉽게 매핑 가능
- 단 `AttributeConverter` 를 사용하려면 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 함

### 4.3.7 밸류를 이용한 ID 매핑

- 식별자라는 의미를 부각시키기 위해 식별자 자체를 밸류 타입으로 만들 수 있음
- 밸류 타입을 식별자로 매핑하면 `@Id` 대신 `@EmbeddedId` 애너테이션을 사용
- JPA 에서 식별자 타입은 `Serializable` 타입이어야 하므로 식별자로 사용할 밸류 타입은 `Serializable` 인터페이셔를 상속받아야 함
- 밸류 타입으로 식별자를 구현할 때 얻을 수 있는 **장점**은 식별자에 기능을 추가할 수 있다는 점

### 4.3.8 별도 테이블에 저장하는 밸류 매핑

- 애그리거트에서 루트 엔티티를 뺀 나머지 구성요소는 대부분 밸류
- 루트 엔티티 외에 또 다른 엔티티가 있다면 진짜 엔티티인지 의심해 봐야 함
- 밸류가 아니라 엔티티가 확실하다면 해당 엔티티가 다른 애그리거트는 아닌지 확인해야 함
  - 특히 자신만의 독자적인 라이프 사이클을 갖는다면 구분되는 애그리거트일 가능성이 높음
- 애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지를 확인하는 것

### 4.3.9 밸류 컬렉션을 @Entity 로 매핑하기

- 개념적으로 밸류인데 구현 기술의 한계나 팀 표준 때문에 `@Entity` 를 사용해야 할 때도 있음
  - JPA `@Embeddable` 타입의 클래스 상속 매핑을 지원하지 않기 때문에 상속 구조를 갖는 밸류 타입을 사용하려면 `@Entity` 사용해야 함
- `@Entity` 로 매핑해도 밸류 타입이면 상태를 변경하는 기능은 추가하지 않음
- `@OneToMany`, cascade, `opphanRemoval = true` 사용
- `@Entity` 에 대한 `@OneToMany` 매핑에서 컬렉션의 `clear()` 메서드를 호출하면 삭제 과정이 효율적이지 않음
  - select 쿼리로 대상 엔티티를 로딩하고, 각 개별 엔티티에 대해 delete 쿼리 실행
- 하이버네이트는 `@Embeddable` 타입에 대한 컬렉션의 `clear()` 메서드를 호출하면 컬렉션에 속한 객체를 로딩하지 않고 한 번의 delete 쿼리로 삭제 처리를 수행
  - 타입에 따라 다른 기능을 구현하려면 if-else 를 이용해야 함
- 코드 유지 보수와 성능의 두 가지 측면을 고려해서 구현 방식을 선택

### 4.3.10 ID 참조와 조인 테이블을 이용한 단방향 M-N 매핑

- 애그리거트 간 집합 연관은 성능 상의 이유로 좋지 않음
- 그럼에도 불구하고 요구사항을 구현하는 데 집합 연관을 사용하는 것이 유리하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있음
- `@ElementCollection` 을 이용하기 때문에 루트 엔티티를 삭제할 떄 매핑에 사용한 조인 테이블의 데이터도 함께 삭제됨
- 애그리거트를 직접 참조하는 방식응 사용했다면 영속성 전파나 로딩 전략을 고민해야 함

## 4.4 애그리거트 로딩 전략

- 즉시로딩을 사용하면 카타시안(cartesian) 조인을 사용하고 쿼리 결과에 중복을 발생시켜서 메모리에서 중복 제거
  - 데이터 개수가 많아지면 성능(실행 빈도, 트래픽, 지연 로딩 시 실행 속드 등) 검토해봐야 함
- 애그리거트는 개념적으로 하나여야 하지만 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아님
- 애그리거트가 완전해야 하는 이유
  - 상태를 변경하는 기능을 실행할 떄 애그리거트 상태가 완전해야 함
    - 상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 잉요해서 애그리거트를 완전한 상태로 로딩할 필요는 없음
  - 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요
    - 조회 전용 기능과 모델을 구현하는 방식이 더 유리
- 지연 로딩은 동작 방식이 항상 동일하기 때문에 즉시 로딩처럼 경우의 수를 따질 필요가 없다는 **장점**

## 4.5 애그리거트의 영속성 전파

- 애그리거트가 완전한 상태여야 한다는 것은 상태여야 한다는 것은 애그리거트 루트를 조회할 때 뿐만 아니라 저장하고 삭제할 떄도 하나로 처리해야 함을 의미
- `@Embeddable` 매핑 타입은 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 됨
- `@Entity` 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제 시에 함께 처리되도록 설정

## 4.6 식별자 생성 기능

- 식별자 생성 방식
  - 사용자가 직접 생성
  - 도메인 로직으로 생성
  - DB 를 이용한 일련번호 사용
- 이메일 주소처럼 사용자가 직접 식별자를 입력하는 경우는 식별자 생성 주체가 사용자이기 때문에 도메인 영역에 식별자 생성 기능을 구현할 필요 없음
- 식별자 생성 규칙이 있다면 엔티티를 생성할 때 식별자를 엔티티가 별도 서비스로 식별자 생성 기능을 분리해야 함
  - 응용 서비스는 이 도메인 서비스를 이용
  - 리포지터리에 이 기능을 구현할 수도 있음
- 자동 증가 칼럼, JPA의 식별자 생성 기능은 DB 에 저장하는 시점에 식별자를 생성
  - 도메인 객체를 생성하는 시점에는 식별자를 알 수 없고 도메인 객체를 저장한 뒤에 식별자를 구할 수 있음

## 4.7 도메인 구현과 DIP

- 엔티티와 리포지터리에서 구현 기술인 JPA 에 의존 발생
- DIP 를 적용하는 주된 이유는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록 하기 위함
- 리포지터리와 도메인 모델의 구현 기술은 거의 바뀌지 않음
- 이렇게 변경이 거의 없는 상황에서 변경을 미리 대비하는 것은 과할 수 있음
- 도메인 모델과 리포지터리의 테스트 가능성도 해치지 않음
