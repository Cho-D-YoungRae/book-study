# Chapter 10. 이벤트

## 10.1 시스템 간 강결합 문제

- 외부 시스템을 호출할 때 문제
  - 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야 할지 애매
  - 성능에 대한 것: 외부 시스템의 응답 시간이 길어지면 그 만큼 대기 시간도 길어짐
- 도메인 객체에 서비스를 전달하면 설계상 문제 발생 가능
  - 서로 다른 도메인 로직이 뒤섞임
  - 기능을 추가할 때 더욱 문제
- 위 문제들이 발생하는 이유는 두 바운디드 컨텍스트 간의 강결합
- 강한 결합을 없앨 수 있는 방법은 **이벤트**

## 10.2 이벤트 개요

- 이벤트
  - 과거에 벌어진 어떤 것
  - 상태가 변경됐다는 것을 의미
  - 이벤트가 발생하면 이벤트에 반응하여 원하는 동작을 수행하는 기능 구현

### 10.2.1 이벤트 관련 구성 요소

- `이벤트`, `이벤트 생성 주체`, `이벤트 디스패처(퍼블리셔)`, `이벤트 핸들러(구독자)`
- `이벤트 생성주체`: 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
- `이벤트 핸들러`: 이벤트 생성 주체가 발생한 이벤트에 반응
- `이벤트 디스패처`: 이벤트 생성 주체와 이벤트 핸들러를 연결
  - 이벤트 생성과 처리를 동기나 비동기로 실행

### 10.2.2 이벤트의 구성

- 이벤트는 발생한 이벤트에 대한 정보를 담음
  - 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
  - 이벤트 발생 시간
  - 추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보
- 이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 데이터를 담아야 하는데 이 데이터가 부족하면 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 함
- 이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없음

### 10.2.3 이벤트 용도

- 도메인의 상태가 바뀔 때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거
- 서로 다른 시스템 간의 데이터 동기화

### 10.2.4 이벤트 장점

- 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있음
- 기능 확장도 용이

## 10.3 이벤트 핸들러 디스패처 구현

- 이벤트 클래스: 이벤틀르 표현
- 디스패처: 스프링이 제공하는 `ApplicationEventPublisher`를 이용
- Events: 이벤트를 발행. 이벤트 발행을 위해 `ApplicationEventPublisher`를 사용.
- 이벤트 핸들러: 이벤트를 수신해서 처리. 스프링이 제공하는 기능을 사용.

### 10.3.1 이벤트 클래스

- 이벤트 자체를 위한 상위 타입은 존재하지 않으므로 원하느 클래스를 이벤트로 사용하면 됨
  - 발생 시간과 같이 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있음
- 이벤트 클래스의 이름을 결정할 때는 과거 시제를 사용
  - 접미사로 Event를 사용하거나 간결함을 위해 과거 시제만 사용할 수도 있음
- 이벤트를 처리하는 데 필요한 최소한의 데이터를 포함

### 10.3.2 Events 클래스와 `ApplicationEventPublisher`

- 스프링 컨테이너는 `ApplicationEventPublisher`도 됨
- `ApplicationContext`는 `ApplicationEventPublisher`를 상속

### 10.3.3 이벤트 발생과 이벤트 핸들러

- 이벤트를 처리할 핸들러는 스프링이 제공하느 `@EventListener` 애너테이션을 사용해서 구현
- `ApplicationEventPublisher#publishEvent()` 메서드를 특정 이벤트 타입 객체를 전달하면, 해당 이벤트 타입을 갖는 `@EventListener` 애너테이션을 붙인 메서드를 찾아 실행

### 10.3.4 흐름 정리

- 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행

## 10.4 동기 이벤트 처리 문제

- 이벤트를 사용해서 강결합 문제는 해소했지만 외부 서비스에 영향을 받는 문제가 남음
  - 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결
  - 트랜재션 문제: 외부 서비스 실행에 실패했다고 반드시 트랜잭션을 롤백해야 하는지
- 이벤트를 비동기로 처리하거나 이벤트와 트랜잭션을 연계해서 문제 해결 가능

## 10.5 비동기 이벤트 처리

- 'A 하면 이어서 B 하라' 는 내용을 담고 있는 요구사항은 실제로 'A 하면 최대 언제까지 B 하라'인 경우가 많은데 이런 요구사항은 이벤트를 비동기로 처리하는 방식으로 구현 가능
- 비동기 이벤트 처리를 구현하는 방법
  - 로컬 핸들러를 비동기로 실행하기
  - 메시지 큐를 사용하기
  - 이벤트 저장소와 이벤트 포워더 사용하기
  - 이벤트 저장소와 이벤트 제공 API 사용하기

### 10.5.1 로컬 핸들러 비동기 실행

- 이벤트 핸들러를 비동기로 실행하는 방법은 이벤트 핸들러를 별도 스레드로 실행하는 것
  - `@EnableAsync` 애너테이션을 사용해서 비동기 기능을 활성화
  - 이벤트 핸들러 메서드에 `@Async` 애너테이션을 붙임

### 10.5.2 메시징 시스템을 이용한 비동기 구현

- 비동기로 이벤트를 처리해야 할 때 사용하는 또 다른 방법은 카프카나 래빗MQ와 같은 메시징 시스템을 사용하는 것
  - 이벤트가 발생하면 이벤트 디스패터는 이벤트를 메시지 큐에 보냄
  - 메시지 큐는 이벤트를 메시지 리스너에 전달
  - 메시지 리스너는 알맞은 이벤트 핸들러를 이용해서 이벤트를 처리
  - 이벤트를 메시지 큐에 저장하는 과정과 멧지ㅣ 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리
- 필요하다면 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 함 -> 글로벌 트랜잭션 이용
  - 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점
  - 전체 성능이 떨어지는 단점
- 메시지 큐를 사용하면 보통 이벤트를 발생시키는 주체와 이벤트 핸들러가 별도 프로세스에서 동작
  - 이벤트 발생 JVM과 이벤트 처리 JVM이 다름
  - 한 JVM에서 처리할 수 있지만 복잡해질 수 있음

### 10.5.3 이벤트 저장소를 이용한 비동기 처리

- 이벤트를 일단 DB에 저장한 뒤에 별도 프로그램을 이용해서 이벤트 핸들러에 전달
- 포워더 방식
  - 포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행
  - 포워더는 별도 스레드를 이용하기 때문에 이벤트 발행과 처리가 비동기로 처리
  - 도메인의 상태와 이벤트 저장소로 동일한 DB 를 사용 -> 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리
  - 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있음
- API 방식
  - 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져감
  - 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억

## 10.6 이벤트 적용 시 추가 고려 사항

- 이벤트 소스를 EventEntry 에 추가할지 여부
  - 특정 주체가 발생 시킨 이벤트만 조회하는 기능
- 포워더에서 전송 실패를 얼마나 허용할 것
  - 특정 이벤트에서 계속 전송에 실패하면 그 이벤트 떄문에 나머지 이벤트를 전송할 수 없게 됨
- 이벤트 손실
  - 이벤트 저장소를 사용하는 방식은 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장 가능
  - 반면 로컬 핸들러를 이용해서 이벤트를 이동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실
- 이벤트 순서
  - 이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우 이벤트 저장소를 사용하는 것이 좋음
  - 반면 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 전달 순서가 다를 수 있음
- 이벤트 재처리
  - 마지막으로 처리한 이벤트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시
  - 이벤트를 멱등으로 처리

### 10.6.1 이벤트 처리와 DB 트랜잭션 고려

- 이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 함
- 트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 됨
  - 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것
  - `@TransactionalEventListener` 애너테이션은 스프링 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 함
  - 이벤트 특성에 따라 재처리 방식 결정
