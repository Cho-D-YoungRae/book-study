# Chapter 06. 응용 서비스와 표현 영역

## 6.1 표현 영역과 응용 영역

- 도메인이 제 기능을 하려면 사용자와 도메인을 연결해 주는 매개체가 필요한데 응용 영역과 표현 영역이 이 역할
- 표현 영역은 사용자의 요청을 해석
- 응용 영역은 실제 사용자가 원하는 기능을 제공
- 표현 영역은 응용 서비스가 요구하는 형식으로 사용자 요청을 변환
- 사용자와 상호작용은 표현 영역이 처리하기 떄문에, 응용 서비스는 표현 영역에 의존하지 않음

## 6.2 응용 서비스의 역할

- 사용자(클라이언트)가 요청한 기능 실행
- 도메인 영역과 표현 영역을 연결해주는 창구
- 주로 도메인 객체 간의 흐름을 제어하기 떄문에 단순한 형태를 갖음
- 응용서비스가 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높음
- 트랙잭션 처리
- 접근 제어
- 이벤트 처리

### 6.2.1 도메인 로직 넣지 않기

- 도메인 로직은 도메인 영역에 위치하고 응용 서비스는 도메인 로직을 구현하지 않아야 함
- 도메인 로직을 도메인 영역과 응용 서비스에 분산해서 구현하면 코드 품질에 문제 발생
  - 코드의 응집성이 떨어짐
  - 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐
  - 위 문제들은 결과적으로 코드 변경을 어렵게 만듬

## 6.3 응용 서비스의 구현

- 응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사드(facade)와 같은 역할을 함

### 6.3.1 응용 서비스의 크기

- 응용 서비스는 보통 다음 두가지 방법 중 한 가지 방식으로 구현
  - 한 응용 서비스 클래스에 도메인의 모든 기능 구현
    - 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일한 로직에 대한 코드 중복을 제거할 수 있다는 **장점**
      - 존재하지 않는 엔티티 조회 시 예외 처리 등
    - 한 서비스 클래스의 크기(코드 줄 수)가 커진다는 **단점**
      - 연관 성이 적은 코드가 한 클래스에 위치할 가능성 높아짐 -> 관련 없는 코드가 뒤섞여 코드를 이해하는 데 방해
  - 구분되는 기능별로 응용 서비스 클래스를 따로 구현
    - 한 응용 서비스 클래스에서 한 개 내지 2~3개의 기능을 구현
    - 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있는데, 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있음

### 6.3.2 응용 서비스의 인터페이스와 클래스

- 응용 서비스를 구현할 때 논쟁이 될 만한 것이 인터페이스가 필요한지
- 구현 클래스가 여러 개인 경우
  - 구현 클래스가 다수 존재하거나 런타임에 구현 객체를 교체해야 할 때
  - 이런 경우가 드물고 인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현 클래스에 대한 간접 참조가 증가해서 전체 구조가 복잡
  - 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 선택이라고 볼 수는 없음
- TDD 를 즐겨하고 표현 영역부터 개발을 시작한다면, 미리 응용 서비스를 구현할 수 없으므로 응용 서비스의 인터페이습부터 작성하게 될 것
  - 표현 영역부터 개발하는 것이 아니면 Mockito 와 같은 테스트 도구는 클래스에 대해서도 테스트용 대역 객체를 만들 수 있음

### 6.3.3 메서드 파라미터와 값 리턴

- 응용 서비스가 제공하는 메서드는 도메인을 이용해서 사용자가 요구한 기능을 실행하는 데 필요한 값을 파라미터로 전달받아야 함
- 개별 파라미터로 전달받을 수도 있고 별도 데이터 클래스를 만들어 전달받을 수도 있음
- 응용 서비스의 결과를 표현 영역에서 사용해야 하면 응용 서비스 메서드의 결과로 필요한 데이터를 리턴
- 응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 있지만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 됨
  - 코드의 응직도를 낮춤
  - 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 좋음

### 6.3.4 표현 영역에 의존하지 않기

- 응용 서비스의 파라미터 타입을 결정할 떄 **주의할 점**은 표현 영역과 관련된 타입을 사용하면 안 됨
- 응용 서비스에서 표현 영역에 대한 의존이 발생하면
  - 응용 서비스만 단독으로 테스트하기 어려워짐
  - 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경해야 함
  - 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수 있음

### 6.3.5 트랜잭션 처리

## 6.4 표현 영역

- 사용자가 시스템을 사용할 수 있는 흐름(화면)을 제공하고 제어
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
- 사용자의 세션을 관리

## 6.5 값 검증

- 값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행할 수 있음
- 원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리
- 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 함
- 표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 ID 중복 여부와 같은 논리적 오류만 검사하면 됨
- 응용 서비스를 사용하는 표현 영역 코드가 한 곳이면 구현의 편리함을 위해 다음과 같이 역할을 나누어 검증을 수행할 수도 있음
  - 표현 영역: 필수 값, 값의 형식, 범위 등
  - 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류
- 가능하면 응용 서비스에서 필수 값 검증과 논리적인 검증을 모두 하는 것이 좋음
  - 작성할 코드가 증가하는 불편함
  - 응용 서비스의 완성도 높아짐

## 6.6 권한 검사

- 개발하는 시스템마다 권한의 복잡도가 다름
  - 인증 여부만 검사
  - 관리자인지 확인
  - 역할마다 다른 권한
- 다음 세 곳에서 권한 검사를 수행할 수 있음
- 표현 영역에서 할 수 있는 기본적인 검사는 인증된 사용자인지 검사하는 것
- 이런 접근 제어를 하기 좋은 위치가 서블릿 필터
- 개별 도메인 객체 단위로 권한 검사를 해야 하는 경우는 구현이 복잡해짐
  - 예) 게시글 삭제는 본인 또는 관리자 역할을 가진 사용자만 가능

## 6.7 조회 전용 기능과 응용 서비스

- 서비스 코드가 단순히 조회 전용 기능을 호출하는 형태로 끝나면 수행하는 추가적인 로직이 없을뿐더러 단일 쿼리만 실행하는 조회 전용 기능이어서 트랜잭션이 필요하지도 않음
- 이 경우라면 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 문제가 없음
