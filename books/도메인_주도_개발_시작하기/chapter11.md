# Chapter 11. CQRS

## 11.1 단일 모델의 단점

- 조회 화면 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야 함
  - 식별자를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩 방식과 같은 JPA 쿼리 관련 최적화 기능을 사용할 수 없으므로 한 번의 SELECT 쿼리로 조회 화면에 필요한 데이털르 읽어올 수 없어 조회 성능에 문제가 생길 수 있음
  - 애그리거트 간 연관을 식별자가 아니라 직접 참조하는 방식으로 연결하면 조회 화면 특성에 따라 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하고 조회 기능을 구현할 떄 DBMS 가 제공하는 전용 기능이 필요하면 JPA 의 네이티브 쿼리를 사용해야 함
- 이런 구현 복잡도를 낮추는 방법으로 **상태 변경을 위한 모델과 조회를 위한 모델을 분리**하는 것

## 11.2 CQRS

- 시스템이 제공하는 기능은 크게 두 가지: 상태를 변경하는 기능, 상태 정보를 조회하는 기능
- 도메인 모델 관점에서 상태 변경 기능은 주로 한 애그리거트의 상태를 변경하는 반면, 조회 기능에 필요한 데이터를 표시하려면 두 개 이상의 애그리거트가 필요할 때가 많음
- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해지는데 이를 해결하기 위한 방법 -> CQRS
- `CQRS`(Commane Query Responsibility Segregation): 상태를 변경하는 명령(Command)을 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리
- 복잡한 도메인에 적합
- 각 모델에 맞는 구현 기술을 선택할 수 있음
- 상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현
- 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고 있는 데이터 타입을 이용
- 명령 모델과 조회 모델이 같은 구현 기술을 사용할 수도 있음
- 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있음
  - 두 데이터 저장소 간 데이터 동기화는 이벤트를 활용해서 처리

### 11.2.1 웹과 CQRS

- 일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많음
- 쿼리를 최적화해서 쿼리 실행 속도 자체를 높이고, 메모리에 조회 데이터를 캐싱해서 응답 속도를 높이기도 함. 조회 전용 저장소를 따로 사용하기도 함.
- 메모리에 캐싱하는 데이터는 DB에 보관된 데이터를 그대로 저장하기 보다는 화면에 맞는 모양으로 변환한 데이터를 캐싱 할 때 성능에 더 유리함 즉, 조회 전용 모델을 캐싱

### 11.2.2 CQRS 장단점

- 장점
  - 명령 모델을 구현할 때 도메인 자체에 집중할 수 있음
  - 조회 성능을 향상시키는 데 유리
- 단점
  - 구현해야 할 코드가 더 많아짐
  - 더 많은 구현 기술 필요
