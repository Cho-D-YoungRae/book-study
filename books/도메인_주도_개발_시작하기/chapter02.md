# Chapter 02. 아키텍처 개요

## 2.1 네 개의 영역

- 표현 영역(또는 UI 영역)은 사용자의 요청을 받아 응용 영역에 전달하고 응용 여역의 처리 결과를 다시 사용자에게 보여주는 역할
- 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용
- 응용 서비스는 로직을 직접 수행하기보다는 도메인 모델에 로직 수행을 위임
- 인프라스트럭처 영역은 구현 기술에 대한 것을 다룸
  - RDBMS 연동 처리, 메시징 큐에 메시지 전송/수신, 몽도DB나 레디스와의 데이터 연동 처리, SMTP를 이용한 메일 발송 기능, REST API 호출, ...

## 2.2 계층 구조 아키텍처

> 표현 -> 응용 -> 도메인 -> 인프라스트럭처

- 도메인 복잡도에 따라 응용과 도메인을 분리하기도 하고 한 계층으로 합치기도 함
- 계층 구조는 그 특성상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않음
- 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래의 계층에만 의존을 가져야 하지만 구현의 편리함을 위해 계층 구조를 유연하게 적용하기도 함
- 인프라스트럭처에 의존하면 '테스트 어려움'과 '기능 확장의 어려움'이라는 두 가지 문제가 발생

## 2.3 DIP

- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 하는데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제, 즉 구현 변경과 테스트가 어렵다는 문제 발생
- DIP 는 이 문제를 해결하기 위해 추상화한 인터페이스(고수준)을 통해 저수준 모듈이 고수준 모듈에 의존하도록 바꿈
- 저수준 모듈 구현 클래스는 고수준의 추상화한 인터페이스를 상속받아 구현
- 고수준 모듈이 저수준 모듈을 하용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle), 의존 역전 원칙 이라고 함
- DIP 를 적용하면 앞의 다른 영역이 인프라스트럭처 영역에 의존할 때 발생했던 두 가지 문제인 구현 교체가 어렵다는 것과 테스트가 어려운 문제를 해소할 수 있음
  - 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인텊-이승- 의존하므로 실제 사용할 저수준 구현 객체는 의존 주입을 이용해서 전달받을 수 있음
  - 고수준 구현체가 저수준 모듈에 직접 의존했다면 저수준 모듈이 만들어지기 전까지 테스트를 할 수 없었겠지만 추상화한 인터페이스에 의존하면 대역 객체를 사용해서 테스트를 진행할 수 있음

### 2.3.1 DIP 주의사항

- DIP 를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들일 수 있음
- DIP 의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데 DIP 를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 추출하는 경우가 있음
- DIP 를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출

### 2.3.2 DIP 와 아키텍처

- 인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영역과 도메인 영역은 고수준 모듈
- 인프라스트럭처 계층이 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 됨

> DIP를 항상 적용할 필요는 없다. 사용하는 구현 기술에 따라 완벽한 DIP를 적용하기보다는 구현 기술에 의존적인 코드를 도메인에 일부 포함하는 게 효과적일 때도 있다. 또는 추상화 대상이 잘 떠오르지 않을 때도 있다. 이럴 때는 무조건 DIP를 적용하려고 시도하지 말고 DIP의 이점을 얻는 수준에서 적용 범위를 검토해보자.

## 2.4 도메인 영역의 주요 구성요소

|요소|설명|
|---|---|
|엔티티(Entity)|고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖는다. 주문(Order), 회원(Member), 상품(Product)와 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 고나련된 기능을 함께 제공한다.|
|밸류(Value)|고유의 식별자를 갖지 않는 객체로 주로 개념적으로 하나인 값을 표현할 때 사용된다. 배송지 주소를 표현하기 위한 주소(Address)나 구매 금액을 위한 금액(Money)와 같은 타입이 밸류 타입이다. 엔티티의 속성으로 사용할 뿐만 아니라 다른 밸류 타입의 속성으로도 사용할 수 있다.|
|애그리거트(Aggregate)|애그리거트는 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. 예를 들어 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 '주문' 애그리거트로 묶을 수 있다.|
|리포지터리(Repository)|도메인 모델의 영속성을 처리한다. 예를 들어 DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다.|
|도메인 서비스(Domain Service)|특정 엔티티에 속하지 않은 도메인 로직을 제공한다. '할인 금액 계산'은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다.|

### 2.4.1 엔티티와 밸류

- 실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이 아님
- 이 두 모델의 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점
- 또 다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것

### 2.4.2 애그리거트

- 도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 바로 애그리거트(Aggregate)
- 애그리거트는 관련 객체를 하나로 묶은 군집
- 애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있음
- 애그리거트는 군집에 속한 객체를 관리하는 루트 엔티티를 갖음
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공
  - 애그릭거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근
  - 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 도움
- 애그리거트를 구현할 때 고려할 것
  - 애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고, 트랜잭션 범위가 달라지기도 함
  - 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 함

### 2.4.3 리포지터리

- 도메인 객체를 지속적으로 사용하려면 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야 하는데, 이를 위한 도메인 모델이 리포지터리(Repository)

## 2.5 요청 처리 흐름

### 표현 영역

- 사용자가 전송한 데이터 형식이 올바른지 검사
- 문제가 없다면 데이터를 이용해서  응용 서비스에 기능 실행을 위임
- 사용자가 전송한 데이터를 응용 서비스가 요구하느 형식으로 변환해서 전달

### 응용 서비스

- 도메인 모델을 이용해서 기능을 구현
- 기능 구현에 필요한 도메인 객체를 리포지터리에서 가져와 실행하거나 신규 도메인 객체를 생성해서 리포지터리에 저장
- 두 개 이상의 도메인 객체를 사용해서 구현하기도 함

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원
- 무조건 인프라스트럭처에 대한 의존을 없앨 필요는 없음
  - 스프링을 사용할 경우 응용 서비스는 트랜잭션 처리를 위해 스프링이 제공하는 `@Transactional`을 사용하는 것이 편리
  - 영속성 처리를 위해 JPA를 사용할 경우 `@Entity`나 `@Table`과 같은 JPA 전용 애너테이션을 도메인 모델 클래스에 사용하는 것이 XML 매핑 설정을 이용하는 것 보다 편리
- 구현의 편리함은 DIP가 주는 다른 장점(변경의 유연함, 테스트 쉬움)만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 나쁘지 않음

## 2.7 모듈 구성

- 아키텍처의 각 영역은 별도의 패키지에 위치
- 도메인이 크면 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성
- 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성
- 애그리거트, 모델, 리포지터리는 같은 패키지에 위치
- 한 패키지에 가능하면 10~15개 미만으로 타입 개수를 유지하는 것이 좋고, 이 개수가 넘어가면 패키지 분리를 고려
