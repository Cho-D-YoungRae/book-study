# Chapter 03. 애그리거트

## 3.1 애그리거트

- 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트
- 애그리거트는 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 됨
- 애그리거트는 관련된 모델을 하나로 모았기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖음
- 애그리거트는 경계를 갖음
  - 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항
- 흔히 'A가 B를 갖는다'로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽지만 반드시 그렇지는 않음
  - 예) 상품과 리뷰
- 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어듦
- 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많았으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물음

## 3.2 애그리거트 루트

- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데, 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티

### 3.2.1 도메인 규칙과 일관성

- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 꺠지지 않도록 하는 것
- 이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 꺠는 원인이 됨
- 불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 도메인 모델에 대해 다음 두 가지를 습관적으로 적용
  - 단순히 필드를 변경하는 set 메서드를 공개(public) 범위를 만들지 않음
  - 밸류 타입은 불변으로 구현

### 3.2.2 애그리거트 루트의 기능 구현

- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성
- 애그리거트 루트가 구성요소의 상태만 참조하는 것은 아님. 기능 실행을 위임하기도 함.

### 3.2.3 트랜잭션 범위

- 트랜잭션 범위는 작을 수록 좋음
- 성능에서도 차이가 발생
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 함
- 한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 의미
- 만약 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 두 애그리거트를 수정하도록 구현
- 도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경하느 코드를 작성할 수 있음
- 한 트랜잭션에서 한 개의 애그리거트를 변경하는 것을 권장하지만, 다음 경우에는 한 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있음
  - 팀 표준: 팀이나 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우가 있음
  - 기술 제약: 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 함
  - UI 구현의 편리: 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶은 것이다. 이 경우 한 트랜잭션에서 여러 주문 애그리거트의 상태를 변경해야 한다.

## 3.3 리포지터리와 애그리거트

- 애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화 해야 함
- 애그릭거트를 구하는 리포티저리 메서드는 완전한 애그리거트를 제공해야 함

## 3.4 ID를 이용한 애그리거트 참조

- 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트의 루트를 참조한다는 것과 같음
- 필드를 이용한 애그리거트 참조는 다음 **문제**를 야기할 수 있음
  - 편한 탐색의 오용
    - 다른 애그리거트의 상태를 쉽게 변경한 수 있게 됨
  - 성능에 대한 고민
    - 지연(lazy) 로딩과 즉시(eager) 로딩
  - 확장 어려움
    - 하위 도메인마다 서로 다른 DBMS 사용
- ID를 이용한 애그리거트 참조를 통해 위 문제를 완화할 수 있음
- 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결
  - 애그리거트의 경계를 명확히하고 애그리거트 간 물리적인 연결을 제거하기 떄문에 모델의 복잡도를 낮춤
  - 애그리거트 간의 의존을 제거하므로 응집도를 높여줌
- 구현 복잡도 낮아짐
  - 지연 로딩, 즉시 로딩 고민 필요 없음
- 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 근원적으로 방지 가능
- 애그리거트별로 다른 구현 기술 사용 가능

### 3.4.1 ID를 이용한 참조와 조회 성능

- 다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽을 때 조회 속도가 문제 될 수 있음
  - N + 1 문제
- 조회 전용 쿼리를 통해 위 문제 해결 가능
- 조회 화면에서 필요한 애그리거트 데이터를 한 번의 쿼리로 로딩 가능
- 쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 마이바이스와 같은 기술을 이용해서 구현할 수도 있음
- 애그리거트마다 서로 다른 저장소를 사용하면 한 번의 쿼리로 관련 애그리거트를 조회할 수 없음
  - 조회 성능을 높이기 위해 캐시를 적용하거나
  - 조회 전용 저장소를 따로 구성
    - 단점: 코드가 복잡
    - 장점: 시스템의 처리량을 높일 수 있음

## 3.5 애그리거트 간 집합 연관

- 애그리거트 간 1-N 관계는 Set과 같은 컬렉션을 이용해서 표현 가능
- 개념적으로 존재하는 애그리거트 간의 1-N 연관을 실제 구현에 반영하는 것이 요구사항을 충족하는 것과는 상관없을 때가 있음
- 개념적으로는 애그리거트 간에 1-N 연관이 있더라도 성능 문제가 있을 경우(페이징 적용이 필요한 경우 등) 애그리거트 간의 1-N 연관을 실제 구현에 반영하지 않음
- M-N 연관도 실제 요구사항을 고려하여 M-N 연관을 구현에 포함시킬지를 결정해야 함

## 3.6 애그리거트를 팩토리로 사용하기

- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려
- 애그리거트를 생성할 때 많은 정보를 알아야 한다면 특정 애그리거트에서 직접 생성하지 않고 다른 팩토리에 위임하는 방법도 있음
- 도메인 응집도가 높아짐