# Chapter 02. 분해 전략

## 2.1 마이크로서비스 아키텍처란 무엇인가?

마이크로 서비스 아키텍처의 핵심 사상은 기능 분해

### 2.1.1 소프트웨어 아키텍처의 정의와 중요성

#### 소프트웨어 아키텍처의 정의

> 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트(element)와 그들 간의 관계, 그리고 이 둘의 속성(property)으로 구성된 시스템을 추론하는 데 필요한 구조(structure)의 집합이다.

- 핵심은 애플리케이션 아키텍처가 여러 파트(엘리먼트)로의 분해와 이런 파트 간의 관계(연관성)
- 분해가 중요한 이유
  - 업무와 지식을 분리합니다. 덕분에 전문 지식을 보유한 사람들(또는 여러 팀)이 함께 생산적으로 애플리케이션 작업을 할 수 있습니다.
  - 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힙니다.

#### 소프트웨어 아키텍처의 4+1 뷰 모델

> [위키피디아](https://en.wikipedia.org/wiki/4%2B1_architectural_view_model)  
> 4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의합니다. 각 뷰는 아키텍처의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그들 사이의 관계로 구성됩니다.

- **논리 뷰(logical view)**: 개발자가 작성한 소프트웨어 엘리먼트. 객체 지향 언어라면 클래스, 패키지가 해당되며 결국 상속(inheritance), 연관(association), 의존(depends-on) 등 클래스와 패키지의 관계를 말합니다.
- **구현 뷰(implementation view)**: 빌드 시스템의 결과물. 모듈(패키징된 코드)과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성됩니다. 자바에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일입니다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함됩니다.
- **프로세스 뷰(process view)**: 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고, IPC는 프로세스 간 관계를 나타냅니다.
- **배포 뷰(deployment view)**: 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 (물리 또는 가상) 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹입니다. 프로세스 머신 사이의 관계도 이 뷰에서 기술됩니다.
- +1 에 해당하는 뷰를 구동시키는 시나리오. 각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍처 요소가 협동하여 요청을 처리하는지 기술

#### 아키텍처의 중요성

- 애플리케이션의 두 가지 요건
  1. 애플리케이션이 해야 할 일을 정의한 기능 요건
     - 아키텍처와 거의 무관
  2. 이른바 '~성'으로 긑나는 서비스 품질 요건
     - 아키텍처는 바로 이 요건을 충족시킬 수 있게 설계해야 함
     - 서비스 품질 요건은 확장성, 신뢰성 같은 런타임 품질 외에도 관리성, 테스트성, 배포성처럼 개발 시점의 품질도 해당

### 2.1.2 아키텍처 스타일 개요

- 특정 아키텍처 스타일은 엘리먼트(컴포넌트)와 관계(커넥터)의 한정된 팔레트(palette, 사용 가능한 범위)를 제공하며, 이를 토대로 애플리케이션 아키텍처의 뷰를 정의할 수 있음
- 애플리케이션은 대부분 아키텍처 스타일을 조합해서 사용

#### 계층화 아키텍처 스타일

- 소프트웨어 엘리먼트를 계층별로 구성하는 계층화 아키텍처
- 전형적인 아키텍처 스타일
- 계층마다 명확히 정의된 역할을 분담
- 계층 간 디펜던시는 아키텍처로 제한
- 어떤 계층은 바로 하위에 있는 계층에만 의존하거나 하위에 위치한 어느 한 계층에 의존
- 3계층 아키텍처는 계층화 아키텍처를 논리 뷰에 적용한 사례
  - **표현(프레젠테이션) 계층(presentation layer)**: 사용자 인터페이스 또는 외부 API가 구현된 계층
  - **비즈니스 로직 계층(business logic layer)**: 비즈니스 로직이 구현된 계층
  - **영속화(퍼시스턴스) 계층(persistence layer)**: DB 상호 작용 로직이 구현된 계층
- 계층화 아키텍처의 몇 가지 중요한 흠
  - **표현 계층이 하나뿐이다**: 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
  - **영속화 계층이 하나뿐이다**: 애플리케이션이 상호 작용하는 DB가 정말 하나뿐일까?
  - **비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다**: 이론적으로 이런 디펜던시 때문에 DB 없이 비즈니스 로직을 테스트하는 것은 불가능합니다.
  - 잘 설계된 애플리케이션에서 디펜던시를 잘못 나타내는 문제

#### 육각형 아키텍처 스타일

- 논리 뷰를 비즈니스 로직 중심으로 구성하는 계층화 아키텍처 스타일의 대안
- 애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터를 둠
- 비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 가장 중요한 특장점. 외려 어댑터가 비즈니스 로직에 의존
- 비즈니스 로직에는 하나 이상의 포트
- 포트는 비즈니스 로직이 자신의 외부 세계와 상호 작용하는 방법이 정의된 작업
  - 가령 자바라면 인터페이스가 포트
- 포트 종류는 인바운드/아웃바운드 두 가지
  - 인바운드 포트는 비즈니스 로직이 표출된 API 로서, 외부 애플리케이션은 이 API 를 통해 비즈니스 로직을 호출
  - 아운바운드 포트는 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 것
- 어댑터는 비즈니스 로직 주변을 감싸고 있음
- 포트처럼 어댑터도 인바운드/아웃바운드 두 종류
- 인바운드 어댑터는 외부에서 들어온 요청을 인바운드 포트를 호출해서 처리
- 동일한 인바운드 포트를 여러 인바운드 어댑터가 호출할 수도 있음
- 아웃바운드 어댑터는 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리
- 아웃바운드 어댑터는 이벤트를 발행하기도 함
- 육각형 아키텍처 스타일의 가장 큰 장점은 비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 떄문에 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점
  - 이렇게 분리를 하니 비즈니스 로직만 따로 테스트하기도 쉬움
  - 현대 애플리케이션 아키텍처를 좀 더 정확하게 반영 가능

### 2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다

- 모놀리식 아키텍처는 구현 뷰를 단일 컴포넌트로 구성한 아키텍처 스타일
  - 다른 뷰는 일체 등장하지 않음
  - 모놀리식 애플리케이션은 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 있음
- MSA도 일종의 아키텍처 스타일
  - 구현 뷰를 다수의 컴포넌트로 구성하는 차이점
  - 컴포넌트는 곧 서비스, 각 서비스는 자체 논리 뷰 아키텍처를 갖음
  - 전형적인 육각형 아키텍처
- MSA 의 핵심 제약 조건은 서비스를 느슨하게 결합한다는 것
  - 따라서 여러 서비스가 협동하는 방식에도 제약 사항이 있음

#### 서비스란 무엇인가?

- 서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
- 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드, 쿼리, 이벤트로 구성된 API를 제공
- 서비스 작업은 크게 커맨드(command, 명령/CUD)와 쿼리(query, 조회/R)로 나뉨
- 클라이언트가 소비하는 OrderCreated 같은 이벤트를 발행하기도 함
- 서비스 API는 내부 구현 상세를 캡슐화
- 모놀리스와 달리 개발자는 API를 우회하여 서비스에 접근하는 코드를 작성할 수 없으므로 MSA에서 애플리케이션 모듈성은 보장
- 각각의 마이크로서비스는 자체 아키텍처를 갖고 있기 떄문에 기술 스택을 독자적으로 구축할 수 있지만 대부분 육각형 아키텍처 형태를 취함
- API 는 서비스에 구현된 비즌티스 로직과 소통하는 어댑터를 이용하여 구현
- 작업 어댑터(operations adapter)는 비즈니스 로직을 호출, 이벤트 어댑터(events adapter)는 비즈니스 로직이 내어 준 이벤트를 발행
- 서비스 구현 뷰는 스탠드얼론(standalone) 프로세스, 컨테이너 내부에서 실행되는 웹 애플리케이션, OSGI 번들, 서버리스 클라우드 기능 등 다양한 컴포넌트를 이용할 수 있음
  - 서비스마다 자체 API 를 갖고 독립적인 배포가 가능해야 하는 것이 핵심 요건

#### 느슨한 결합

- MSA 의 주요 특성 중 하나
- 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드 변경 가능
- 느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과
- 개발자가 서비스를 이해하고, 변경하고, 테스트하기 쉬움
- 서비스는 느슨하게 결합되고 API 를 통해서만 동작하기 때문에 다른 서비스 DB 와 통신하는 일은 불가능
- 클래스 필드 같은 서비스의 영속적인 데이터는 반드시 프라이빗으로 유지
- 개발자가 자신이 맡은 서비스의 DB 스키마를 변경할 떄 다른 서비스 개발자와 조율하느라 시간을 허비하지 않음
- 서비스가 DB 테이블을 공유하지 않기 때문에 런타임 격리(runtime isolation)도 향상
  - 어떤 서비스가 DB 락을 획득하여 다른 서비스를 블로킹 하는 일 자체가 불가능
- DB 를 공유하지 않기 때문에 여러 서비스에 걸쳐 데이터를 쿼리하고 일관성을 유지하는 일은 더 복잡해지는 **단점**

#### 공유 라이브러리의 역할

- 코드 중복을 방지하기 위해 여러 애플리케이션에서 재사용 가능한 기능을 라이브러리(모듈)로 패키징함
- MSA 에서도 공유 라이브러리를 사용하서 서비스 코드 중복을 줄이는 것은 좋지만 의도치 않은 서비스 간 결합도를 유발하지 않도록 조심
  - 사용하는 라이브러리가 업데이트 되어야 하면 관련 서비스를 일제히 다시 빌드해서 배포해야 함
- 바뀔 일이 거의 없는 기능은 라이브러리에 담아 쓰는 것이 좋음

#### 서비스 규모는 별로 중요하지 않다

- 크기보다는 작은 팀이, 가장 짧은 시간에, 다른 팀과 협동하는 부분은 최소로 하여 개발 가능한 서비스를 설계해야 함

## 2.2 마이크로서비스 아키텍처 정의

1. 애플리케이션 요건을 핵심 요청으로 추출
   - 요청을 REST, 메시징 같은 특정 IPC 기술이 아닌 좀 더 추상적인 관념으로 시스템 작업
2. 어떻게 여러 서비스로 분해할지 결정
   - 비즈니스 능력에 따라 서비스를 정의할 수 있음
   - DDD 의 하위 도메인별로 서비스를 구성할 수 있음
3. 서비스별로 API를 정의

- 분해 과정에서 장애물
  - 네트워크 지연
    - 서비스 간 왕복이 너무 잦아 분해할 수 없는 경우 있음
  - 서비스 간 동기 통신으로 인해 가용성이 떨어질 수 있음
    - 해결책: 자기 완비형 서비스(self-contained service)
  - 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건
    - 사가로 해결
  - 애플리케이션 도처에 숨어 있는 만능 클래스
    - DDD 개념을 활용하면 어렵지 않게 제거 가능

### 2.2.1 시스템 작업 식별

- 애플리케이션 아키텍처를 정의하는 첫 단추는 시스템 작업을 정의하는 일
- 그 출발점은 사용자 스토리와 이와 연관된 사용자 시나리오 등의 애플리케이션 요건
- 1단계는 시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성하는 것
- 2단계는 시스템 작업 식별 후 그 동작을 도메인 모델 관점에서 기술하는 것
- 도메인 모델은 주로 사용자 스토리의 명사에서 도출
  - 이벤트 스토밍(event storming)이라는 기법을 사용해도 됨
- 시스템 작업은 주로 동사에서 도출하며, 각각 하나 이상의 도메인 객체와 그들 간의 관계로 기술
  - 도메인 모델을 생성, 수정, 삭제하거나 모델 간의 관계를 맺고 끊을 수 있음
- 고수준 도메인 모델과 시스템 작업을 보면 애플리케이션이 무슨 일을 하는지 알 수 있기 때문에 아키텍처를 정의하는 데 유용
- 시스템 작업을 정의한 후에는 애플리케이션 서비스를 식별

#### 고수준 도메인 모델 생성

- 시스템 작업을 정의하려면 우선 고수준 애플리케이션 도메인 모델을 대략 그려 봄
- 도메인 모델은 스토리에 포함된 명사를 분석하고 도메인 전문가와 상담하는 등 표준 기법을 활용하여 생성

#### 시스템 작업 정의

- 애플리케이션이 어떤 요청을 처리할지 식별하는 단계
- 시스템 작업은 크게 두 종료
  - 커맨드(command, 명령): 데이터 생성, 수정, 삭제(CUD)
  - 쿼리(query, 조회): 데이터 읽기(R)
- 시스템 작업은 결국 REST, RPC 메시징 엔드포인트로 구현되겠지만, 지금은 일단 추상적으로 생각
- 시스템 커맨드를 식별하려면 사용자 스토리/시나리오에 포함된 동사를 분석
- 커맨드는 매개변수, 반호나값, 동작 방식의 명세를 도메인 모델 클래스로 정의
  - 이 명세는 작업 호출 시 충족되어야 할 선행조건(precondition), 작업 호출 후 충족되어야 할 후행 조건(postcondition)으로 구성

### 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해

- MSA 를 구축하는 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것
- 비즈니스 아키텍처 모델링에서 비롯된 비즈니스 능력은 비즈니스가 가치를 생산하기 위해 하는 일

#### 비즈니스 능력은 곧 조직이 하는 일이다

- 비즈니스 능력을 보면 그 조직의 비즈니스가 무엇인지 알 수 있음
- 조직이 비즈니스를 하는 방법은 그때마다 다르고 급격히 변하기도 하지만 비즈니스 능력은 대체로 크게 달라지지 않음

#### 비즈니스 능력 식별

- 한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별
- 기술보다 비즈니스 위주라는 점만 제외하면 일종의 서비스로 볼 수도 있음
- 비즈니스 능력 명세는 입력, 출력, SLA 등 다양한 컴포넌트로 구성
- 비즈니스 능력은 보통 특정 비즈니스 객체에 집중하며, 여러 개의 하위 능력으로 분해할 수 있음

#### 비즈니스 능력을 여러 서비스로

- 비즈니스 능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의
- 능력 체계의 어느 수준(level)을 서비스에 매핑할지는 주관적으로 판단할 문제

### 2.2.3 서비스 정의: 하위 도메인 패턴별 분해

- DDD: 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법. 도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법.
- 기존에는 전체 비즈니스를 포괄하는 단일 통합 모델을 만들었음
  - 이렇게 모델링하면 하나의 모델에 대해 조직 내 여러 부서의 합의를 이끌어 내기가 정말 어려운 단점
  - 부서마다 상이한 개념을 동일한 용어로 표현하는 일도 비일비재
- DDD 는 범위가 분명한 도메인 모델을 여러 개 정의하여 기존 방식의 문제점을 해결하는 전혀 다른 방식의 모델링

### 2.2.4 분해 지침

- 비즈니스 능력에 따른 분해, 하위 도메인에 따른 분해는 MSA 를 정의하는 주요 수단
- 이 밖의 객체 지향 설계에 근거한 두 가지 원칙
  - 단일 책임 원칙(SRP, Single Responsibility Principle), 공동 폐쇄 원칙(CCP, Common Closure Principle)
  - MSA 에 위 두 원칙을 적용

#### 단일 책임 원칙(SRP, Single Responsibility Principle

> 클래스는 오직 하나의 변경 사유를 가져야 한다.

- 클래스가 맡은 책임은 각각 그 클래스가 변경될 잠재적 사유
- 클래스가 독립적으로 변경 가능한 책임을 여럿 짊어지고 있다면 안정적일 수 없음
- MSA 에 적용하면 하나의 책임만 가진 작고 응집된 서비스를 정의

#### 공동 폐쇄 원칙(CCP, Common Closure Principle)

> 패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.

- 즉, 어떤 두 클래스가 동일한 사유로 맞물려 변경되면 동일한 패키지에 있어야 함
- CCP 를 잘 지키면 애플리케이션의 유지보수성이 현저히 향상
- MSA 에 적용하면 동일한 사유로 변경되는 컴포넌트를 모두 같은 서비스로 묶을 수 있음

### 2.2.5 서비스 분해의 장애물

- 네트워크 지연
- 동기 통신으로 인한 가용성 저하
- 여러 서비스에 걸쳐 데이터 일관성 유지
- 데이터의 일관된 뷰 확보
- 분해를 저해하는 만능 클래스

#### 네트워크 지연

- 서비스를 여러 개로 나누면 서비스 간 왕복 횟수가 급증
- 한 차례 왕복으로 여러 객체를 한 번에 가져오는 배치 API를 구현하거나, 값비싼 IPC를 언어 수준의 메서드나 함수 호출로 대체하는 식으로 서비스 결합에 따른 지연 시간 줄임

#### 동기 IPC 로 인한 가용성 저하

- 비동기 메시징으로 강한 결합도를 제거하고 가용성을 높이는 방법

#### 여러 서비스에 걸쳐 데이터 일관성 유지

- 과거에는 커밋 방식의 2단계(2PC) 분산 트랜잭션을 많이 썼지만, 요즘 애플리케이션에는 잘 안맞기 떄문에 사가(saga)라는 전혀 다른 방식으로 트랜잭션 관리
  - 사가는 메시징을 이용한 일련의 로컬 트랜잭션
  - 기존 ACID 트랜잭션보다는 복잡하지만 다양한 상황에서도 잘 동작
  - 한 가지 단점은 최종 일관성(eventual consistency)을 보장
  - 어떤 데이터를 원자적으로 업데이트해야 한다면 그 데이터를 하나의 서비스 내부에 두어야 하는데, 이는 결국 분해의 걸림돌이 됨

#### 일관된 데이터 뷰 확보

- 여러 DB 에 걸쳐 일관된 데이터 뷰를 확보하기도 어려움
- 모놀리식 애플리케이션에서는 ACID 트랜잭션의 속성 덕분에 어떻게 쿼리를 하든 일관된 데이터 뷰가 반환되지만, MSA 는 각 서비스의 DB 가 일관적이라 해도 전역 범위에서 일관된 데이터 뷰는 확보할 수 없음

#### 만능 클래스는 분해의 걸림돌

- 애플리케이션 곳곳에 사용되는 만능 클래스는 그 존재만으로도 분해의 걸림돌
- 이런 클래스에는 대부분 애플리케이션의 여러 측면에 관한 비즈니스 로직이 있는데, 굉장히 많은 필드가 다수의 컬럼을 가진 DB 테이블에 매핑된 경우가 많음
- 만능 클래스는 애플리케이션의 여러 측면의 상태/동작을 보이지 않게 감싸고 있기 때문에 이 클래스를 사용하는 전체 비즈니스 로직을 서비스로 분리하려면 골치 아픔

### 2.2.6 서비스 API 정의

- 서비스 API 작업은 외부 클라이언트 또는 타 서비스가 호출하는 시스템과 서비스 협동을 지원하기 위해 타서비스 호출 전용으로 만든 작업
- 서비스 이벤트는 주로 타 서비스와 협동하기 위해 발행
  - 사가 구현
  - CQRS 뷰를 업데이트하고 쿼리를 효과적으로 지원
  - 애플리케이션이 외부 클라이언트에 알림을 보내는 용도
- 각각의 시스템 작업을 서비스로 매핑한 후, 그 시스템 작업을 구현하려면 어느 서비스가 서로 협동해야 할지 파악

#### 시스템 작업을 서비스로 배정

- 제일 먼저 어느 서비스가 요청의 진입점인지 결정
- 시스템 작업을 각 서비스에 배정한 후, 각 시스템 작업을 처리하기 위해 서비스가 어떻게 협동해야 할지 결정

#### 서비스 간 협동 지원에 필요한 API 확정

- 서비스 하나로 전부 처리 가능한 시스템 작업도 있지만, 작업은 대부분 여러 서비스에 걸쳐 있음
