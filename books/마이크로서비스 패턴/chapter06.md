# Chapter 06. 비즈니스 로직 개발: 이벤트 소싱

- 이벤트 발행 로직이 비즈니스 로직에 추가되기 때문에 개발자가 실수로 이벤트 발행 로직을 빠뜨려도 비즈니스 로직은 그냥 흘러갈 것
  - 버그의 원천이 될 수 있음
- 모든 변경 이력을 애그리거트에 고스란히 보존

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발

> 이벤트 소싱 패턴: 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장

- 이벤트 소싱은 비즈니스 로직을 구성하고 애그리거트를 저장하는 또 다른 방법
- 애그리거트는 일력의 이벤트 형태로 저장
- 이벤트는 각 애그리거트의 상태 변화를 나타냄
- 애플리케이션은 이벤트를 재연(replay)하여 애그리거트의 현재 상태를 재생성
- **장점**
  - 애그리거트 이력이 보존되므로 감사/통제 용도로도 가치가 있음
  - 도메인 이벤트를 확실하게 발행할 수 있어서 마이크로서비스 아키텍처에서 유용
- **단점**
  - 비즈니스 로직을 작성하는 방법이 특이해서 학습시간 필요
  - 이벤트 저장소를 쿼리하기가 쉽지 않아 CQRS 패턴을 적용해야 함

### 6.1.1 기존 영속화의 문제점

- 객체-관계 임피던스 부정합(object-relational impedance mismatch)
- 애그리거트 이력이 없음
- 감사 로깅을 구현하기 번거롭고 에러가 잘 남
- 이벤트 발행 로직이 비즈닛스 로직에 추가

#### 객체-관계 임피던스 부정합

- 테이블 형태의 관계형 스키마와 관계가 복잡한 리치 도메인 모델(rich domain model)의 그래프 구조는 근본적인 개념부터 다름

#### 애그리거트 이력이 없다

- 기존 영속화 매커니즘은 현재 애그리거트의 상태만 저장
- 즉, 애그리거트가 업데이트되면 이전 상태는 사라지고 없음
- 애그리거트 이력을 관리 용도로 온전히 보존하려면 개발자가 직접 코들르 구현하는 데 시간이 걸리고, 비즈니스 로직과 동기화 해야하는 코드를 중복 생성하게 됨

#### 감사 로깅은 구현하기 힘들고 오류도 자주 발생한다

- 감사는 보안/통제 때문에도 필요하지만 사용자 액션 이력 자체가 중요한 경우도 있음
- 감사 로깅은 구현하는 데 시간이 걸림
- 감사 로깅 코드 및 비즈니스 로직이 계속 분화하기 떄문에 버그가 날 가능성이 높음

#### 이벤트 발행 로직이 비즈니스 로직에 추가된다

- 기존 영속화는 도메인 이벤트 발행을 지원하지 않음
- 감사도 그랬듯 개발자는 이벤트 생성 로직을 추가해야 하는데, 자칫 비즈니스 로직과 동기화되지 않을 위험이 있음

### 6.1.2 이벤트 소싱 개요

- 이벤트 소싱은 이벤트를 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장
- 각 이벤트는 애그리거트의 상태 변화를 나타냄
- 애그리거트의 비즈니스 로직은 이벤트를 생산/소비하는 요건 중심으로 구성

#### 이벤트를 이용하여 애그리거트를 저장

- 애그리거트를 DB에 있는 이벤트 저장소에 일련의 이벤트로 저장
- 애그리거트 생성/수정 시 애플리케이션은 애그리거트가 발생시킨 이벤트를 EVENTS 테이블에 삽입
- 애그리거트를 로드할 떄 이벤트 저장소에서 이벤트를 가져와 재연
  - 애그리거트의 이벤트를 로드
  - 기본 생성자를 호출하여 애그리거트의 인스턴스를 생성
  - 이벤트를 하나씩 순회하며 apply() 호출

#### 이벤트는 곧 상태 변화

- 도메인 이벤트는 애그리거트의 변경을 구독자에게 알리는 장치
- 이벤트는 애그리거트 ID 같은 최소한읜 필수 데이터만 넣거나 컨슈머에 유용한 데이터까지 포함시켜 강화할 수 있음
- 어떤 이벤트에 무엇을 전달할지는 컨슈머의 필요에 따라 좌우되지만, 이벤트 소싱에서는 주로 애그리거트에 의해 이벤트 및 그 구조가 결정
- 생성을 비롯한 모든 애그리거트의 상태 변화를 도메인 이벤트로 나타내며, 애그리거트는 상태가 바뀔 때마다 반드시 이벤트를 발생
  - 컨슈머가 관심을 가질만한 이벤트만 발생시켰던 것과 비교하면 훨씬 엄격한 요건
- 이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있음

#### 애그리거트 매서드의 관심사는 오직 이벤트

- 비즈니스 로직은 애그리거트의 업데이트 요청을 애그리거트 루트에 있는 커맨드 메서드를 호출하여 처리
- 이벤트를 발생시켜 적용하려면 비즈니스 로직을 다시 구성해야 함
  - 이벤트 소싱은 커맨드 메서드 하나를 둘 이상의 메서드로 리펙터링
  - 첫 번째 메서드는 요청을 나타낸 커맨드 객체를 매개변수로 받아 상태를 어떻게 변경해야 할지 결정
    - 이 메서드는 매개변수 확인 후 애그리거트 상태는 바꾸지 않고 상태 변경을 나타낸 이벤트 목록을 반환
    - 수행할 수 없는 커맨드라면 예외
  - 다른 메서드는 각자 정해진 이벤트 타입을 매개변수로 받아 애그리거트를 업데이트
    - 이벤트는 이미 발생한 상태 변경을 나타내므로 이런 메서드는 실패할 수 없음 
- 애그리거트 생성
  1. 기본 생성자로 애그리거트 루트 초기화
  2. process() 를 호출하여 새 이벤트를 발생
  3. 새 이벤트를 하나씩 순회하면서 apply() 를 호출하여 애그리거트를 업데이트
  4. 이벤트 저장소에 새 이벤트를 저장
- 애그리거트 업데이트
  1. 이벤트 저장소에서 애그리거트 이벤트를 로드
  2. 기본 생성자로 애그리거트 루트를 초기화
  3. 가져온 이벤트를 하나씩 순회하며 애그리거트 루트의 apply() 를 호출
  4. process() 를 호출하여 새 이벤트를 발생
  5. 새 이벤틀르 순회하면서 apply() 를 호출하여 애그리거트를 업데이트
  6. 이벤트 저장소에 새 이벤트를 저장

#### 이벤트 소싱 기반의 Order 애그리거트

### 6.1.3 동시 업데이트: 낙관적 잠금

- 여러 요청이 동일한 애그리거트를 동시에 업데이트하는 일은 드물지 않음
- 기존 영속화 메커니즘은 대개 한 트랜잭션이 다른 트랜잭션의 변경을 덮어 쓰지 못하게 낙관적 잠금을 하여 처리
- 이벤트 저장소 역시 낙관적 잠금 기법으로 동시 업데이트를 처리할 수 있음
  - 이벤트에 딸려 온 버전 정보를 각 애그리거트 인스턴스마다 두고, 애플리케이션이 이벤틀르 삽입할 때 이벤트 저장소가 버전 변경 여부를 체크
  - 이벤트 번호를 버전 번호로 사용
  - 이벤트 저장소에서 명식저으로 버전 번호 관리

### 6.1.4 이벤트 소싱과 이벤트 발생

- 이벤트 소싱 기반의 애플리케이션도 폴링, 트랜잭션 로그 테일링 등 방법으로 DB 에 삽입된 메시지를 트랜잭션의 일부로 발행
- 이벤트를 OUTBOX 테이블에 잠깐 저장했다 지우는 것이 아니라, EVENTS 테이블에 영구 저장하는 차이점

#### 이벤트 발행: 폴링

- 이벤트를 EVENTS 테이블이 저장한다고 가정하면, 이벤트 발행기는 SELECT 문으로 새 이벤트를 계속 폴링하면서 메시지 브로커에 발행
- 어느 이벤트가 새 이벤트인지 분간해야 함
- EVENT_ID 단순히 1만큼 증가하면, 이벤트 발행기가 자신이 처리한 마지만 EVENT_ID 를 기록하면 됨
- 트랜잭션이 이벤트를 발생시키는 순서와 다르게 커밋할 수 있고, 따라서 이벤트 발행기가 실수로 이벤트를 건너뛰게 될 수도 있음
- 이런 문제를 해결하는 한 가지 방법은 EVENTS 테이블에 이벤트 발행 여부를 추적할 수 있는 칼럼을 추가하여 이벤트 발행기가 이벤트를 건너뛰지 않도록 함

#### 이벤트 발행: 트랜잭션 로그 테일링

- 트랜잭션 로그 테일링이 좀 더 정교한 방법
- 이벤트 발행을 확실히 보장하면서도 성능/확장성이 우수

### 6.1.5 스냅샷으로 성능 개선

- 상태 전이가 별로 없는 이벤트는 이벤트 저장소를 쿼리해서 애그리거트를 재구성하는 것이 효율적
- 수명이 긴 애그리거트는 이벤트 수가 꽤 많아서 로드/폴드하기가 만만찮음
- 그래서 주기적으로 애그리거트 상태의 스냅샷을 저장하고, 가장 최근에 뜬 스냅샷과 그 이후 발생한 이벤트만 가져오는 식으로 애그리거트 상태를 복원
- 스냅샷을 사용할 경우, 애그리거트 인스턴스는 기본 생성자가 아닌 스냅샷을 이용하여 재생성

### 6.1.6 멱등한 메시지 처리

- 메시지 브로커가 동일한 메시지를 여러 번 전송할 가능성이 있으므로 메시지 컨슈머는 멱등하게 개발해야 함
- 이벤추에이트 트램 프레임워크는 비즈니스 로직이 애그리거트를 생성/수정하는 로컬 ACID 트랜잭션의 일부로 처리한 메시지 ID를 PROCESSED_MESSAGES 테이블에 기록해서 메시지 ID가 있으면 중복 메시지 이므로 솎아내면 됨
- 이벤트 소싱 기반의 비즈니스 로직은 이런 메커니즘을 강구해야 하는데, 구현 방법은 이벤트 저장소가 사용하는 DB 가 RDBMS 인지, NoSQL DB 인지에 따라 다름

#### RDBMS 이벤트 저장소 사용

- 메시지 ID 는 PROCESSED_MESSAGES 테이블에, 이벤트는 EVENTS 테이블에 삽입하는 트랜잭션의 일부로 삽입

#### NoSQL 이벤트 저장소 사용

- NoSQL 기반의 이벤트 저장소는 트랜잭션 모델이 제한적이라서 메시지를 멱등하게 처리하려면 다른 수단을 강구해야 함
- 메시지 컨슈머는 이벤트를 젖아하고 메시지 ID 를 기록하는 작업을 어느정도 원자적으로 처리해야 함
- 메시지 컨슈머가 메시지 처리 도중 생성된 메시지 ID 를 저장
- 해당 메시지 ID 가 애그리거트의 이벤트에 있는지 확인하면 중복 메시지 여부를 알 수 있음
- 메시지 처리 결과 아무 이벤트도 생성되지 않으면 문제가 발생할 수 있으므로 항상 이벤트를 발행해야 함

### 6.1.7 도메인 이벤트 발전시키기

- 정확성을 담보로 변경 감사 로그를 제공하여 애플리케이션이 애그리거트 상태를 온전히 재구성할 수 있는 반면, 이벤트 구조는 시간이 흐름에 따라 계속 달라지기 때문에 새로운 문제가 생기게 마련
- 애플리케이션은 잠재적으로 여러 버전의 이벤트를 처리해야 함

#### 이벤트 스키마

- 이벤트 소싱에 기반한 애플리케이션의 스키마는 개념상 다음 세 가지로 구성
  - 하나 이상의 애그리거트로 구성
  - 각 애그리거트가 발생시키는 이벤트를 정의
  - 이벤트 구조를 정의

|수준|변경|하위 호환성|
|---|---|---|
|스키마|새 애그리거트 타입 정의|O|
|애그리거트 삭제|기존 애그리거트 삭제|X|
|애그리거트 개명|애그리거트 타입명 변경|X|
|애그리거트|새 이벤트 타입 추가|O|
|이벤트 삭제|이벤트 타입 삭제|X|
|이벤트 개명|이벤트 타입명 변경|X|
|이벤트|새 필드 추가|O|
|필드 삭제|필드 삭제|X|
|필드 개명|필드명 변경|X|
|필드 타입 변경|필드 타입 변경|X|

- 하위 호환성이 보장되는 변경도 있지만, 그렇지 않은 것도 있음

#### 업캐스팅을 통한 스키마 변화 관리

- 이벤트 소싱 프레임워크가 이벤트 저장소에서 이벤트를 로드할 때 바꾸어 줌
- 보통 업캐스터(upcaster)라고 하는 컴포넌트가 개별 이벤트를 구 버전에서 신 버전으로 업데이트하므로 애플리케이션 코드는 현재 이벤트 스키마를 잘 처리하기만 하면 됨

### 6.1.8 이벤트 소싱의 장점

- 도메인 이벤트를 확실하게 발행
- 애그리거트 이력 보존
- O/R 임피던스 불일치 문제를 대부분 방지 가능
- 개발자에게 타임 머신을 제공

#### 6.1.9 이벤트 소싱의 단점

- 새로운 프로그래밍 모델을 배우는 데 시간이 걸림
- 메시징 기반 애플리케이션은 복잡
- 이벤트를 개량하기가 까다로운 편
  - 이벤트 스키마(그리고 스냅샷)는 시간이 지나면서 조금씩 발전될 것이고, 이벤트는 영구 저장되므로 애그리거트는 각 스키마 버전별로 이벤트를 폴드해야 하는데, 그러다 보면 버전마다 분기 처리하는 코드로 애그리거트가 도배될 가능성이 높음
  - 이벤트를 이벤트 저장소에서 가져올 때 최신 버전으로 업그레이드해서 해결 가능
- 데이터를 삭제하기가 어려움
  - 기존에는 소프트 삭제를 이용
  - 이벤트를 삭제하지 않고 사용자의 개인 정보를 망각
    - 암호화 이용
    - 이메을 등을 기본키로 사용할 경우 UUID 토큰으로 변경해서 사용
- 이벤트 저장소를 쿼리하기가 만만찮음
  - 이벤트 저장소는 대부분 기본키 검색만 지원
  - CQRS 방식으로 쿼리 구현

### 6.2 이벤트 저장소 구현

- 이벤트 소싱 애플리케이션은 이벤트 저장소에 이벤트를 저장
- 이벤트 저장소는 DB 와 메시지 브로커를 합한 것

### 6.2.1 이벤추에이트 로컬 이벤트 저장소의 작동 원리

#### 이벤추에이트 로컬의 이벤트 DB 스키마

- events: 이벤트를 저장
- entities: 엔터티 당 로우 하나
- snapshots: 스냅샷을 저장

#### 이벤추에이트 로컬의 이벤트 브로커를 구독하여 이벤트를 소비

#### 이벤추에이트 로컬 이벤트 릴레이가 이벤트를 DB 에서 메시지 브로커로 전파

- 이벤트 저장소는 이벤트 DB, 메시지 브로커, 이벤트 릴레이

### 6.2.2 자바용 이벤추에이트 클라이언트 프레임워크

#### 애그리거트 정의: ReflectiveMutableCommandProcessingAggregate 클래스

- 애그리거트의 기초 클래스

#### 애그리거트 커맨드 정의

#### 도메인 이벤트 정의

#### AggregateRepository 클래스로 애그리거트 생성, 검색, 수정

- save()
  1. 기본 생성자로 애그리거트 인스턴스를 만듦
  2. process() 를 호출하여 커맨드를 처리
  3. apply() 를 호출하여 생성된 이벤틀르 적용
  4. 생성된 이벤트를 이벤트 저장소에 저장
- update()
  1. 이벤트 저장소에서 애그리거트 조회
  2. process() 를 호출하여 커맨드를 처리
  3. apply() 를 호출하여 생성된 이벤트를 적용
  4. 생성된 이벤트를 이벤트 저장소에 저장

#### 도메인 이벤트 구독

## 6.3 사가와 이벤트 소싱을 접목

- 이벤트 소싱에서는 코레오그래피 사가를 쉽게 이용 가능
- 이벤트 소싱 기반의 비즈니스 로직을 오케스트레이션 기반의 사가에 연계하는 일은 훨씬 어려울 수 있음
- 이벤트 저장소를 사용하는 애플리케이션은 애그리거트를 하나만 생성/수정하고 결과 이벤트(들)를 발행할 수 있는데, 사가의 각 단계는 반드시 원자적으로 수행되어야 하는 액션들로 구성

### 6.3.1 코레오그래피 사가 구현: 이벤트 소싱

- 이벤트 소싱은 속성상 이벤트가 모든 것을 주도하므로 코레오그래피 사가를 아주 쉽게 구현 가능
- 사가 코레오그래피에 이벤트를 사용하면 이벤트의 목적이 이원화되는 문제
  - 이벤트 소싱은 상태 변화를 나타내기 위해 이벤트를 이용하는데, 이벤트를 사가 코레오그래피에 갖다 쓰면 애그리거트는 상태 변화가 없어도 무조건 이벤트를 발생시켜야 함
  - 이런 문제가 있어서 조금 더 복잡하지만 오케스트레이션 사가를 구현하는 것이 최선

### 6.3.2 오케스트레이션 사가 생성

- 사가 오케스트레이터는 일부 서비스 메서드에 의해 생성
  - 다른 서비스 메서드는 애그리거트를 생성/수정
  - 사가 오케스트레이터를 생성
- 서비스는 이 두 가지 액션을 첫 번쨰 액션이 수행되면 두 번째 액션은 최종적으로 실행되는 방식으로 수행

#### 사가 오케스트레이터 작성: RDBMS 이벤트 저장소 사용 서비스

#### 사가 오케스트레이터 작성: NoSQL 이벤트 저장소 사용 서비스

### 6.3.3 이벤트 소싱 기반의 사가 참여자 구현

- 이벤추에이트 로컬처럼 RDBMS 이벤트 저장소를 이용한 서비스라면 별로 어렵지 않게 사가 커맨드 메시지를 원자적으로 처리하고 응답을 보낼 수 있음
  - 이벤추에이트 트램 프레임워크가 시작한 ACID 트랜잭션의 일부로 이벤트 저장소를 업데이트하는 것
- 이벤추에이트 트램 프레임워크와 동일한 트랜잭션으로 묶을 수 없는 이벤트 저장소를 이용하는 서비스는 전혀 다른 방법을 구사해야 함
  - 커맨드 메시지를 멱등하게 처리
  - 응답 메시지를 원자적으로 전송

#### 커맨드 메시지를 멱등하게 처리

#### 응답 메시지를 원자적으로 전송

### 6.3.4 사가 오케스트레이터 구현: 이벤트 소싱
