# Chapter 01. 모놀리식 지옥에서 벗어나라

## 1.1 서서히 모놀리식 지옥에 빠져들다

### 1.1.1 FTGO 애플리케이션 아키텍처

헥사고날 아키텍처(육각형 아키텍처)

### 1.1.2 모놀리식 아키텍처의 장점

- **개발이 간단하다**: IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞추어져 있습니다.
- **애플리케이션을 쉽게 변경할 수 있다**: 코드, DB 스키마를 변경해서 빌드/배포하기 용이합니다.
- **테스트하기 쉽다**: 개발자가 애플리케이션을 띄우고, REST API 를 호출하고, 셀레늄으로 UI를 시험하는 종단 간 테스트를 작성합니다.
- **배포하기 쉽다**: 개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사하면 그만입니다.
- **확장하기 쉽다**: 로드밸런서 뒤에 애플리케이션 인스턴스를 여러 개 실행합니다.

### 1.1.3 모놀리식 지옥의 실상

- 너무 복잡해서 개발자가 주눅 들다
  - 애플리케이션이 복잡해져 여느 개발자가 완전히 이해할 수 없을정도록 내용이 방대해서 버그를 고치고 새 기능을 정확하기 구현하기가 갈수록 힘들고 오래 걸림
  - 개발자가 변경분을 정확히 반영하기 어려움
- 개발이 더디다
  - IDE 느려짐
  - 빌드 시간 증가
  - 시동 시간 증가
  - 코드를 고치고 빌드/실행 후 테스트하기까지 너무 많은 시간 소요
- 커밋부터 배포에 이르는 길고 험난한 여정
  - 여러 개발자가 같은 코드베이스에 소스 커밋을 하다 보니 종종 릴리스할 수 없는 경우 많음
  - 기능 브랜치로 나누더라도 고통스러운 소스 병합 단계
  - 한 팀이 스프린트를 마치면 길고 긴 테스트 및 코드 안정화 기간
  - 테스트 시간이 너무 길어짐
  - 코드베이스가 너무 복잡하여 변경 영향도 파악 어려움
- 확장하기 어렵다
  - 모듈마다 리소스 요건이 서로 맞지 않을 수 있음
  - 인-메모리 DB 를 사용하는 모듈, CPU 를 많이 사용하는 이미지 처리 모듈, ...
  - 같은 애플리케이션이라도 리소스 요건이 상이한 모듈이 존재하므로 서버 구성 시 리소스 배분을 신경써야 함
- 모놀리스는 확실하게 전달하기 어렵다
  - 애플리케이션 자체가 덩치가 커서 철저하게 테스트하기 어려움
  - 테스트성이 부족하면 결국 프로덕션에서 버그가 발생할 가능성도 높음
  - 전체 모듈이 같은 프로세스로 실행되는 까닭에 결함 격리(fault isolation)이 되지 않고, 그러다 보니 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해서 전체 애플리케이션 인스턴스가 내려갈 수 있음
- 갈수록 한물간 기술 스택에 발목이 붙잡히다
  - 새로운 프레임워크, 새로운 프로그래밍 언어를 받아들이기 어려움

## 1.2 이 책의 대상 독자

## 1.3 이 책의 학습 내용

## 1.4 마이크로서비스 아키텍처가 답이다

- 소프트웨어 아키텍처는 기능 요건과는 거의 무관
  - 애플리케이션 기능 요건(functional requirement)는, 즉 유스 케이스(use case, 용례)는 어느 아키텍처든 구현할 수 있음
- 아키텍처는 '~성(-ilities)'로 끝나는 갖가지 서비스 품질 요건(비 기능 요건(nonfunctional requirement))에 적잖이 영향을 미침
  - 관리성(maintinability, 유지보수성), 확장성(extensibility), 테스트성(testability), ...

> 마이크로서비스 아키텍처란 경계 컨텍스트(bounded context)가 있는, 느슨하게 결합된 요소(element)로 구성된 서비스 지향 아키텍처

### 1.4.1 확장 큐브와 마이크로서비스

- 마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일
- 여기서 중요한 것은 크기가 아니라, 각 서비스가 집중된(focused)/응집된(cohesive) 책임을 맡고있다는 사실
- 확장 큐브는 애플리케이션을 확장하는 세 가지 방법을 정의
  1. X축 확장은 다중 인스턴스에 들어온 요청을 부하 분산
  2. Z축 확장은 요청의 속성에 따라 요청을 라우팅
  3. Y축 확장은 애플리케이션을 기능에 따라 서비스로 분해

#### X축 확장: 다중 인스턴스에 고루 요청 분산

- X축 확장은 모놀리식 애플리케이션의 확장 수단
- 로드 밸런서 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 로드 밸런서는 들ㅇ온 요청을 이들 인스턴스에 고루 분배
- 애플리케이션 **능력**과 **가용성**을 개선할 수 있음

#### Z축 확장: 요청 속성별 라우팅

- 모놀리식 애플리케이션의 다중 인스턴스를 실행하는 것은 X축 확장과 같음
- 인스턴스별로 주어진 데이터 하위 집합(subset)만 처리하도록 설정하는 방법
- 인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅(예: userId 에 따라 요청을 분산)
- 애플리케이션을 확장해서 증가하는 **트랜잭션** 및 **데이터 볼륨**을 처리하기 좋은 수단
  - 참고 <https://chanwookpark.github.io/microservice/scalecube/번역/chris/2014/04/12/scale-cube/#z축-확장z-axis-scailing>

#### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해

- X축/Z축 확장을 하면 애플리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 더 복잡해지는 문제는 해결되지 않으므로 Y축 확장, 즉 기능 분해가 필요
  - 모놀리식 애플리케이션을 여러 서비스로 쪼개는 것
- 서비스는 미니 애플리케이션
- 서비스에 따라 X축/Z축 확장도 가능

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다

- 마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용
- 각 서비스는 다른 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 들어올 수 없음
- 따라서 시간이 지나도 애플리케이션 모듈성을 유지하기가 훨씬 수월
- 서비스를 빌딩 블록처럼 사용하여 독립적으로 배포/확장 가능

### 1.4.3 서비스마다 DB가 따로 있다

- 개발 단계에서 다른 서비스 개발자와 일일이 협의하지 않고도 개발자 본인이 담당한 서비스 스키마를 변경할 수 있음
- 런타임에 서비스는 서로 완전히 분리되어 있기 때문에, 이를테면 다른 서비스가 DB 락을 획득해 내 서비스를 블로킹하는 일 따위는 일어나지 않음

### 1.4.4 FTGO 마이크로서비스 아키텍처

### 1.4.5 마이크로서비스 아키텍처와 SOA

"마이크로서비스 아키텍처는 SOA(Service Oriented Architecture, 서비스 지향 아키텍처)와 별반 다를 것이 없다. 전혀 새로운 것이 아니다" 라고들 합니다. 고수준에서 바라보면 SOA와 마이크로서비스, 두 아키텍처 모두 시스템을 여러 서비스로 구성하는 아키텍처 스타일입니다. 하지만 좀 더 깊이 들어가면 근본적인 차이점이 있습니다.

|구분|SOA|마이크로서비스|
|---|---|---|
|서비스 간 통신|SOAP, WS\* 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프(smartpipe)|REST나 gRPC 처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프(dumb pipe)|
|데이터|전역 데이터 모델 및 공유 DB|서비스 개별 데이터 모델 및 DB|
|주요 사례|대규모 모놀리식 애플리케이션|소규모 서비스|

## 1.5 마이크로서비스 아키텍처의 장단점

### 1.5.1 마이크로서비스 아키텍처의 장점

- 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있음
- 서비스 규모가 작아 관리하기 쉬움
- 서비스를 독립적으로 배포/확장할 수 있음
- 마이크로서비스 아키텍처 덕분에 팀이 자율적으로 움직임
- 결함 격리가 잘됨
- 새로운 기술을 실험하고 도입하기 쉬움

#### 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있음

- 마이크로서비스 아키텍처로 구축하면 크고 복잡한 애플리케이션을 지속적 전달/배포할 수 있음
- 마이크로서비스 아키텍처는 다음 세 가지 방법으로 지속적 전달/배포를 실현
  - **테스트성**: 지속적 전달/배포를 하려면 자동화 테스트가 꼭 필요합니다. 마이크로서비스는 상대적으로 크기가 작아서 자동화 테스트를 작성하기 쉽고 더 빨리 실행되며 애플리케이션 버그도 적은 편입니다.
  - **배포성**: 마이크로서비스는 독립적으로 배포할 수 있어서 갭라자가 자신이 담당한 서비스 변경분을 배포할 때 굳이 다른 개발자와 협의할 필요가 없습니다. 그래서 프로덕션에 변경분을 반영하기가 훨씬 수월합니다.
  - **자율성, 느슨한 결함**: 작은 팀이 여럿 결합된 기술 조직을 꾸려 갈 수 있습니다. 팀별로 하나 이상의 관련 서비스를 개발/배포하는 업무만 답당하는 것이죠. 다른 팀과 독립ㅈ거으로 개발, 배포, 확장할 수 있으므로 개발 속도는 더 빨라집니다.
- CI/CD 의 비즈니스 측면 이점
  - 제품을 시장에 내놓는 시기를 앞당길 수 있고 현장에서도 고객 피드백에 신속히 대응할 수 있습니다.
  - 현재 고객들이 기대하는 수준으로 확실하게 서비스를 제공할 수 있습니다.
  - 직원들이 급한 불을 끄느라 에너지를 낭비하는 대신 제품의 가치를 전달하는 데 더 많은 시간을 투자할 수 있어 만족도가 높습니다.

#### 서비스가 작아 관리하기 용이하다

- 비교적 크기가 작아서 개발자가 코드를 이해하기 쉬움
- 코드베이스가 작으면 IDE도 느려지지 않으므로 개발 생산성 올라감
- 서비스를 시동하는 시간이 훨씬 빠르기 때문에 개발자가 작업 후 배포하는 과정 역시 더빠르고 생산적

#### 서비스를 독립적으로 배포/확장할 수 있다

- 독립적으로 X축(복제)/Z축(파티셔닝) 확장을 할 수 있음
- 서비스마다 상이한 리소스 요건에 맞추어 하드웨어에 배포할 수 있음

#### 결함 격리가 잘된다

- 가령 어느 서비스에서 메모리 누수가 발생하더라도 해당 서비스만 영향을 받고 다른 서비스는 계속 정상 가동됨

#### 신기술을 시험/도입하기 쉽다

- 새로운 서비스를 개발할 떄 그 서비스에 가장 알맞은 언어와 프레임워크를 자유롭게 선택 가능

### 1.5.2 마이크로서비스 아키텍처의 단점

- 딱 맞는 서비스를 찾기가 쉽지 않음
- 분산 시스템은 너무 복잡해서 개발, 테스트 배포가 어려움
- 여러 서비스에 걸친 기능을 배포할 때에는 잘 조정해야 함
- 마이크로서비스 아키텍처 도입 시점을 결정하기가 어려움

#### 딱 맞는 서비스를 찾기가 쉽지 않다

- 마이크로서비스 아키텍처에 맞게 시스템을 여러 서비스로 분해하는, 구체적으로 정립된 알고리즘은 따로 없음
- 시스템을 잘못 분해할 경우, 모놀리식/마이크로서비스 아키텍처의 단점만 있는 분산 모놀리스를 구축하게 됨

#### 분산 시스템은 복잡하다

- 분산 시스템이라는 또 다른 복잡성은 개발자가 감당
- 서비스 간 통신에 필수적인 IPC 역시 단순 메서드 호출보다는 복잡
- 사용 불능 또는 지연 시간이긴 원격 서비스, 부분 실패한 서비스를 처리할 수 있게 설계해야 함
- 서비스마다 DB 가 따로 있기 때문에 다중 DB 에 접속하여 조회하고 트랜잭션을 구현하는 일이 어려움
- IDE 와 각종 툴 역시 모놀리식 애플리케이션 개발이 초점이라 여러 서비스가 연관된 테스트를 자동화 하는 것이 쉽지 않음

#### 여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다

- 서비스 간 디펜던시에 따라 서비스 배포 계획을 빈틈없이 수립해야 함

#### 도입 시기를 결정하기 어렵다

- 초기 버전을 개발할 때에는 굳이 MSA 를 사용해서 해결할 이슈가 거의 없음
- 오히려 정교한 분산 아키텍처를 사용하면 개발 속도가 더딜 수 있고 신속하게 이터레이션하기도 어려움

## 1.6 마이크로서비스 아키텍처 패턴 언어

### 1.6.1 마이크로서비스 아키텍처도 만병통치약은 아니다

### 1.6.2 패턴 및 패턴 언어

- `패턴`: 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법
- `패턴 언어`: 특정 영역 내부에서 문제를 해결하는 연관된 패턴의 집합
- 패턴은 적용되는 맥락을 반드시 기술해야 한다는 점에서 가치가 큼
- 패턴이 제시한 솔루션이 어떤 맥락에서는 통하지만 또 다른 어떤 맥락에서는 전혀 통하지 않을 수도 있다는 생각 덕분에 더 나은 방법으로 기술을 논할 수 있게 됨
- 패턴은 맥락을 고려하게 만드는 것 외에도, 매우 중요하지만 자주 간과되는 솔루션의 측면도 함께 기술하도록 강제한다는 점에서 효용성이 큼
- 상용 패턴의 구조는 다음 세 부분으로 구성
  - 강제 조항(forces)
  - 결과 맥락(resulting context)
  - 연관 패턴(related patterns)

#### 강제 조항: 문제 해결을 위해 반드시 처리해야 할 이슈

- 주어진 맥락에서 문제를 해결하고자 할 떄 반드시 처리해야 할 `강제 조항`
- 상충하는 강제 조항도 있기 때문에 모든 조항을 전부 충족할 수는 없고, 어느 조항이 더 중요한지는 맥락에 따라 다르므로 우선순위를 정해야 함

#### 결과 맥락: 패턴 적용 결과

- 패턴을 적용한 결과를 다음 세 부분으로 기술하는 영역
  - 장점: (해결된 강제 조항 등) 패턴의 좋은 점
  - 단점: (미해결 강제 조항 등) 패턴의 나쁜 점
  - 이슈: 패턴 적용 시 발생한 새로운 문제점

결과 맥락은 솔루션을 편견에 치우치지 않은, 좀 더 완전한 시야로 바라보게 합니다. 따라서 더 나은 설계 결정을 내릴 수 있습니다.

#### 연관 패턴: 다섯 가지 관계 유형

한 패턴과 다른 패턴의 관계를 기술하는 영역입니다. 패턴 관계는 다섯 가지 종류가 있습니다.

- 선행자(predecessor): 이 패턴을 필요하게 만든 선행 패턴. 가령 MSA 패턴은 모놀리식 아키텍처 패턴을 제외한 나머지 패턴들의 선행자입니다.
- 후행자(successor): 이 패턴으로 야기된 이슈를 해결하는 패턴. 가령 MSA 패턴을 적용하려면 서비스 디스커버리 패턴, 회로 차단기 패턴 등 후행자 패턴도 함께 적용해야 합니다.
- 대안(alternative): 이 패턴의 대체 솔루션을 제공하는 패턴. 가령 모놀리식 아키텍처 패턴과 마이크로 서비스 아키텍처 패턴은 서로를 대신할 수 있는 애플리케이션 아키텍처링 수단입니다. 둘 중 하나를 선택하면 됩니다.
- 일반화(generalization): 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
- 세분화(specialization): 특정 패턴을 더 세부적으로 나타낸 형태

여러 패턴을 연관 지어 패턴 언어라는 포맷으로 도출하고, 이 패턴 언어의 패턴을 사용하여 특정 영역을 문제를 해결하는 것입니다.

MSA 패턴 언어는 마이크로서비스를 중심으로 서로 관련된 소프트웨어 아키텍처와 디자인 패턴을 취합한 것입니다.

### 1.6.3 마이크로서비스 아키텍처 패턴 언어 개요

#### 애플리케이션을 여러 서비스로 분해하는 패턴

- 비즈니스 능력에 따라 분해
- 하위 도메인에 따라 분해

#### 통신 패턴

- MSA 로 구축한 애플리케이션은 기본적으로 분산 시스템이기 때문에 프로세스 간 통신(IPC)이 중요
- 서비스 상호 간, 그리고 외부 세계와 어떻게 통신하면 좋을지 아키텍처/설계 관점에서 다양한 의사 결정을 해야 함
- 통신 패턴은 크게 다섯 그룹
  - **통신 스타일**: 어떤 종류의 IPC를 사용하는가?
  - **디스커버리**: 서비스 클라이언트는 (이를테면 HTTP 요청을 할 때) 서비스 인스턴스의 IP 주소를 어떻게 가져오는가?
  - **신뢰성**: 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가?
  - **트랜잭셔널 메시징**: 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메시지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가?
  - **외부 API**: 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가?

#### 트랜잭션 관리를 위한 데이터 일관성 패턴

- 기존의 분산 트랜잭션은 서비스마다 DB를 따로 두고 있는 요즘 애플리케이션에는안 맞는 방법
- 사가 패턴(saga pattern)에 따라 데이터 일관성을 유지해야 함

#### 데이터 쿼리 패턴

- 서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제
- API 조합 패턴은 하나 이상의 서비스를 호출해서 그 결과를 조합
- CQRS 는 하나 이상의 데이터 레플리카를 유지해서 쉽게 쿼리하는 방식

#### 서비스 배포 패턴

- 애플리케이션 배포 작업은 모놀리스도 늘 쉬운 것은 아니지만, 배포할 애플리케이션이 하나밖에 없기 때문에 무척 직관적
- 마이크로서비스 애플리케이션은 다양한 언어와 프레임워크로 구현된 수십~수백 개의 서비스로 이루어져 있기 때문에 배포 작업이 훨씬 더 복잡하고 관리할 가동부가 많음

#### 관측성 패턴: 애플리케이션 동작 파악

- 모놀리식 애플리케이션도 운영은 똑같이 어렵지만, 요청이 비교적 단순하고 알기 쉽게 처리되므로 비교적 트러블 슈팅이 수월
- MSA 는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파알 하나만으로는 원인을 파악할 수 없고 문제의 원인을 찾고 진단하기가 매우 복잡
- 지연 시간도 짚어 보아야 할 대상이 많아 원인을 특정하기가 까다로움
- 관측 가능한 서비스를 설계하려면 다음과 같은 패턴 필요
  - **헬스 체크 API**(health check): 서비스 헬스(가동 상태)를 반환하는 엔드포인트를 표출함
  - **로그 수집**(log aggregation): 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공합니다.
  - **분산 추적**(distributed tracing): 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적합니다.
  - **예외 추적**(exception tracking): 예외가 발생하면 예외 추적 서비스에 보고합니다. 이 서비스는 중복된 예외를 걸러내고 개발자에게 경고를 보내거나 그 해결 상태를 추적합니다.
  - **애플리케이션 지표**(application metrics): 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출합니다.
  - **감사 로깅**(auditing metrics): 사용자가 한 일을 기록합니다.

#### 서비스 테스트 자동화 패턴

- MSA 는 단위 서비스 크기가 비교적 작아서 테스트하기 쉽지만, 서로 다른 여러 서비스가 조화롭게 잘 작동되는지 테스트하는 일이 중요
- 느리고 복잡한, 취약한 엔드 투 엔드 테스트는 가급적 피하는 것이 상책
- 다음과 같이 서비스를 따로 분리해서 테스트하는 테스트 단순화 패턴이 필요
  - **컨슈머 주도 계약 테스트(consumer-driven contract test)**: 클라이언트가 의도한 대로 서비스가 동작하는지 확인합니다.
  - **컨슈머 쪽 계약 테스트(consumer-side contract test)**: 클라이언트와 서비스가 상토 통신 가능한지 확인합니다.
  - **서비스 컴포넌트 테스트(service component test)**: 서비스를 따로따로 테스트합니다.

#### 횡단 관심사 처리 패턴

- 모든 서비스가 반드시 구현해야할 관심사가 한두 가지가 아니고, 매개변수를 런타임 서비스에 제공하는 외부화 구성 패턴을 적용해야 함

#### 보안 패턴

- MSA 에서는 일반적으로 API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달
- 가장 일반적인 솔루션은 JWT 같은 액세스 토큰 적용

## 1.7 마이크로서비스 너머: 프로세스와 조직

### 1.7.1 소프트웨어 개발/전달 조직

### 1.7.2 소프트웨어 개발/전달 프로세스

### 1.7.3 마이크로서비스를 받아들이는 인간적 요소
