# Chapter 05. 비즈니스 로직 설계

- 비즈니스 로직이 여러 서비스에 흩어져 있는 MSA 는 복잡한 비즈니스 로직을 개발하기가 까다로움
  - 도메인 모델은 대부분 상호 연관된 클래스가 거미줄처럼 뒤얽혀 있음. 클래스가 여러 서비스에 산재된 MSA 에서는 서비스 경계를 넘나드는 객체 레퍼런스를 제거해야 함
  - MSA 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야 함
- 서비스 비즈니스 로직을 여러 애그리거트로 구성하는 DDD 애그리거트(aggregate, 집합체) 패턴으로 해결 가능
  - 애그리거트는 한 단위로 취급 가능한 객체를 모아 놓은 것
  - 애그리거트를 사용하면 객체 레퍼런스가 서비스를 넘나들 일이 없습니다. 객체 참조 대신 기본키(PK, Primary Key) 를 이용하여 애그리거트가 서로 참조하기 때문
  - 한 트랜잭션으로 하나의 애그리거트만 생성/수정할 수 있습니다. 따라서 애그리거트는 마이크리서비스 트랜잭션 모델의 제약 조건에 잘 맞습니다.

## 5.1 비즈니스 로직 구성 패턴

- 주문 서비스는 비즈니스 로직과 다음 어댑터로 구성
  - REST API 어댑터: 비즈니스 로직을 호출하는 REST API 가 구현된 인바운드 어댑터
  - OrderCommandHandlers: 메시지 채널에서 들어온 커맨드 메시지를 받아 비즈니스 로직을 호출하는 인바운드 어댑터
  - DB 어댑터: 비즈니스 로직이 DB 접근을 위해 호출하는 아웃바운드 어댑터
  - 도메인 이벤트 발행 어댑터: 이벤트를 메시지 브로커에 발행하는 아웃바운드 어댑터
- 비즈니스 로직은 절차적 트랜잭션 스크립트 패턴과 객체 지향적 도메인 모델 패턴, 두 가지 패턴으로 구성

### 5.1.1 비즈니스 로직 설계: 트랜잭션 스크립트 패턴

> 트랜잭션 스크립트 패턴: 비즈니스 로직을 요청 타입 별로 하나씩 매핑된 절찾거 트랜잭션 스크립트 뭉치로 구성

- 간단한 비즈니스 로직 개발 등에는 트랜잭션 스크립트 패턴을 적용하여 절차적인 코드를 작성하는 것이 더 합리적
- 객체 지향 설계를 하지 않고 트랝개션 스크립트라는 메서드를 작성하여 표현 계층에서 들어온 요청을 처리하는 것
- 동작이 구현된 클래스와 상태를 보관하는 클래스가 따로 존재하는 특징

### 5.1.2 비즈니스 로직 설계: 도메인 모델 패턴

> 도메인 모델 패턴: 비즈니스 로직을 상태와 동작을 가진 클래스로 구성된 객체 모델로 구성

- 절차적 접근 방식은 클래스를 어떻게 구성할지 고민하지 않고 단순하게 코딩할 수 있는 매력이 있지만, 비즈니스 로직이 복잡해지면 거의 관리 불가한 상태로 악화
- 객체 지향적으로 설계한 비즈니스 로직은 비교작 작은 클래스가 그물망처럼 얽힌 객체 모델로 구성
- 이런 클래스는 제각기 문제 영역(problem domain) 개념에 직접 대응
- 상태, 동작 둘 중 하나만 있는 클래스도 있지만 대부분은 상태/동작 모두 갖고 있음
- 객체 지향 설계 장점
  - 설계를 이해/관리하기 쉬움
  - 객체 지향 설계는 테스트학 ㅣ쉬움
  - 객체 지향 설계는 잘 알려진 설계 패턴을 응용할 수 있기 때문에 확장하기 쉬움
- 하지만 도메인 모델 패턴도 MSA 에서는 해결해야 할 문제가 많기 때문에 OOD 를 개선한 DDD 가 필요

### 5.1.3 도메인 주도 설계 개요

- DDD 는 복잡한 비즈니스 로직을 개발하기 위해 OOD 를 개선한 접근 방식
- DDD 에서 도메인 모델을 구축하는 데 흔히 쓰이는 빌딩 블록
  - **엔터티(entity)**: 영속적 신원을 가진 객체. 두 엔터티가 속성 값이 동일해도 엄연히 다른 객체입니다.
  - **밸류 객체(value object)**: 여러 값을 모아 놓은 객체. 속성 값이 동일한 두 밸류 객체는 서로 바꾸어 사용할 수 잇습니다.
  - **팩토리(factory)**: 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드. 인스턴스로 생성할 구상 클래스를 감출 수 있으며, 클래스의 정적 메서드로 구현할 수 있습니다.
  - **리포지터리(repository)**: 엔터티를 저장하는 DB 접근 로직을 캡슐화한 객체
  - **서비스(service)**: 엔터티, 밸류 객체에 속하지 않은 비즈니스 로직 구현 객체

## 5.2 도메인 모델 설계: DDD 애그리거트 패턴

- 전통적인 객체 지향 설계에 기반한 도메인 모델은 비즈니스 객체들의 경계가 불분명
- 경계가 불분명하면 MSA 에서 문제가 생길 가능성이 높음

### 5.2.1 불분명한 경계 문제

- 개념적으로 모호하지만 경계가 분명하지 않으면 비즈니스 객체를 업데이트할 때 문제가 생길 수 있음
- 비즈니스 객체 일부를 직접 업데이트하면 결과적으로 비즈니스 규칙을 위반할 수 있음

### 5.2.2 애그리거트는 경계가 분명하다

> 애그리거트 패턴: 도메인 모델을 여러 애그리거트로 구성한다. 각 애그리거트는 한 단위로 취급 가능한 객체망이다.

- 애그리거트는 한 단위로 취급 가능한 경계 내부의 도메인 객체들
- 하나의 루트 엔터티와 하나 이상의 기타 엔터티 + 밸류 객체로 구성
- 비즈니스 객체는 대부분 애그리거트로 모델링
- 애그리거트는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리(chunk)로 분해
- 로드, 수정, 삭제 같은 작업 범위를 분명하게 설정
- 작업은 애그리거트 일부가 아닌 전체 애그리거트에 작용
- 애그리거트는 보통 DB 에서 통째로 가져오기 때문에 복잡한 지연 로딩 문제를 신경 쓸 필요가 없음

#### 애그리거트는 일관된 경계

- 일부가 아니라 전체 애그리거트를 업데이트하므로 일관성 문제 해소
- 업데이트 작업은 애그리거트 루트에서 호출되기 때문에 불변 값이 강제
- 동시성 역시 애그리거트 루트 (버전 번호나 DB 수준의 락으로) 잠금하여 처리

#### 애그리거트를 식별하는 일이 관건

- DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 루트를 식별하는 것

### 5.2.3 애그리거트 규칙

#### 규칙 #1: 애그리거트 루트만 참조하라

- 외부 클래스는 애그리거트의 루트 엔터티만 참조할 수 있게 제한해야 함
- 클라이언트는 애그리거트 루트 메서드만 호출해서 애그리거트를 업데이트할 수 있음
- 이 규칙 덕분에 애그리거트는 자신의 불변 값을 강제할 수 있음

#### 규칙 #2: 애그리거트 간 참조는 반드시 기본키를 사용하라

- 애그리거트는 객체 레퍼런스 대신 신원(예: 기본키)으로 서로를 참조해야 함
- 기존 객체 모델링에서는 외래키(FK, Foreign Key)를 나쁜 설계의 조짐으로 여겼으나 여러 모로 장점이 많음
  - 애그리거트는 느슨하게 결합되고 애그리거트 간 경계가 분명해지기 때문에 혹여 실수로 다른 애그리거트를 업데이트할 일은 일어나지 않음
  - 애그리거트가 다른 서비스의 일부인 경우에도 여러 서비스에 걸친 객체 레퍼런스는 문제 없음
  - 애그리거트는 그 자체가 저장 단위이므로 저장 로직도 간단해짐

#### 규칙 #3: 하나의 트랜잭션으로 하나의 애그리거트를 생성/수정하라

- 하나의 트랜잭션으로 오직 하나의 애그리거트만 생성/수정해야 함
- 모놀리식 애플리케이션에서는 한 트랜잭션으로 여러 애그리거트를 업데이트
- MSA 는 이 제약 조건과 완벽하게 맞아 떨어짐
- 대다수 NoSQL DB 의 제한된 트랜잭션 모델과도 잘 어울림
- 이 규칙을 준수하려면 여러 애그리거트를 생성/수정하는 작업을 구현하기가 조금 복잡해지는데, 이것을 사가로 해결
  - 사가의 각 단계는 정확히 애그리거트 하나를 생성/수정
- 서비스 하나에서 여러 애그리거트에 거쳐 일관성을 유지하는 또 다른 방법은 여러 애그리거트를 한 트랜개션으로 업데이트 하는 것
  - 단순 트랜잭션만 지원하는 NoSQL DB 에서는 사가 외에 별다른 수단이 없음

### 5.2.4 애그리거트 입도

- 도메인 모델에서 각 애그리거트의 크기를 결정하는 일은 매우 중요
- 애그리거트는 작으면 작을수록 좋음
- 각 애그리거트의 업데이트는 직렬화되므로 잘게 나뉘어져 있으면 그만큼 애플리케이션의 동시 처리 가능한 요청 개수가 늘고 확장성이 좋아짐
- 애그리거트 자체가 곧 트랜잭션의 범위라서 어떤 업데이트를 원자적으로 처리하려면 애그리거트를 크게 잡아야 할 수도 있음

### 5.2.5 비즈니스 로직 설계: 애그리거트

- (마이크로) 서비스 비즈니스 로직은 대부분 애그리거트로 구성
  - 나머지는 도메인 서비스와 사가에 위치
- 주문 서비스에 국한된 요청은 애그리거트를 직접 업데이트하고, 여러 서비스에 걸친 업데이트 요청은 사가를 생성해서 처리

## 5.3 도메인 이벤트 발행

> 도메인 이벤트 패턴: 애그리거트는 뭔가생성되거나 중요한 변경이 발생했을 떄 도메인 이벤트를 발행

- DDD 맥락에서 도메인 이벤트는 애그리거트에 발생한 사건

### 5.3.1 변경 이벤트를 발행하는 이유

- 다른 구성원(사용자, 다른 애플리케이션 또는 같은 애플리케이션 내부의 다른 컴포넌트)들이 애그리거트의 상태 변경을 궁금해 하기 떄문에 도메인 이벤트는 유용
  - 코레오그래피 사가를 이용하여 여러 서비스에 걸쳐 데이터 일관성을 유지
  - 레플리카를 둔 서비스에 소스 데이터가 변경되었음을 알림 (CQRS)
  - 미리 등록한 웹훅(webhook)이나 메시지 브로커를 통해 비즈니스 프로세스의 다음 단계를 진행하도록 다른 애플리케이션에 알림
  - 사용자 브라우저에 웹 소켓 메시지를 보내거나, 일래스틱서치 같은 텍스트 DB 를 업데이트 하기 위해 같은 애플리케이션의 다른 컴포넌트에 알림
  - 사용자에게 (텍스트 메시지나 이메일로) 알림
  - 애플리케이션이 제대로 작동되고 있는지 도메인 이벤트를 모니터링 하면서 확인
  - 사용자 행동을 모델링하기 위해 이벤트를 분석

### 5.3.2 도메인 이벤트란 무엇인가?

### 5.3.3 이벤트 강화

- 컨슈머가 필요한 정보를 직접 쿼리해서 가져오면 오버헤드를 유발
- 컨슈머에 필요한 정보를 이벤트가 갖고 다니는 이벤트 강화(event enrichment) 기법
- 컨슈머를 단순화 하는 이점이 있지만, 컨슈머 요건이 바뀌면 이벤트 클래스도 함께 바꾸어야 하므로 이벤트 클래스의 안정성은 떨어짐
- 대부분의 경우는 이벤트 안에 포함시켜야 할 프로퍼티가 명백

### 5.3.4 도메인 이벤트 식별

- 이벤트 스토밍(event storming)이라는 방법을 많이 사용하는 추세
  - 이벤트 브레인스토밍(event brainstorming): 도메인 이벤트를 머릿속에서 쥐어 짜냄
  - 이벤트 트리거(event trigger) 식별: 각각의 이벤트를 일으키는 트리거 식별
  - 애그리거트 식별: 각 커맨드 소비 후 적절한 이벤트를 발생시키는 애그리거트를 식별해서 노란색 점착식 메모지로 표시

### 5.3.5 도메인 이벤트 생성 및 발행

#### 도메인 이벤트 생성

- 개념적으로 도메인 이벤트는 애그리거트가 발행해야 하지만 인프라 관심사와 비즈니스 로직이 뒤엉켜 버릴 수 있음
- 서비스는 디펜던시를 주입하여 메시징 API 를 가리키는 레퍼런스를 획득할 수 있으므로 이벤트를 발행하기가 더 쉬움
- 애그리거트는 상태 전이 시 이벤트를 생성하고, 생성한 이벤트를 두 가지 방법으로 서비스에 반환
  - 애그리거트 메서드 반환값에 이벤트 목록을 넣음 \*
  - 애그리거트 루트의 특정 필드에 이벤트를 차곡차곡 쌓아 두고 서비스가 이벤트를 가져다 발행하는 방법

#### 도메인 이벤트를 확실하게 발행하는 방법

- 도메인 이벤트도 메시지를 로컬 DB 트랜잭션의 일부로 확실하게 전달하듯 확실하게 전달해야 함
- 서비스는 DB 에서 애그리거트를 업데이트하는 트랜잭션의 일부로 이벤트를 발행하기 위해 트랜잭셔널 메시징을 사용해야 함
- 이벤추에이트 트램 프레임워크는 이런 메커니즘이 구현되어 있음
- DB 업데이트 트랜잭션의 일부로 이벤트를 OUTBOX 테이블에 삽입하고, 트랜잭션이 커밋되면 이 테이블에 삽입된 이벤트를 메시지 브로커에 발행

### 5.3.6 도메인 이벤트 소비

- 도메인 이벤트는 결국 메시지로 바뀌어 아파치 카프카 같은 메시지 브로커에 발행

## 5.4 주방 서비스 비즈니스 로직

## 5.5 주문 서비스 비즈니스 로직

- 트랜잭션은 꼭 하나의 애그리거트만 생성/수정할 수 있으므로 애그리거트가 상태 변경 시 도메인 이벤트를 발행할 떄 유리
