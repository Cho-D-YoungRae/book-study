# Chapter 04. 트랜잭션 관리: 사가

- 사가는 ACID 에서 I 가 빠진 ACD 만 지원하고 격리가 되지 않기 때문에 동시 비정상의 영향을 방지하거나 줄일 수 있는 설계 기법을 적용해야 함

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

### 4.1.1 분산 트랜잭션의 필요성

- 서비스마다 DB 가 따로 있기 때문에 여러 DB 에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야 함

### 4.1.2 분산 트랜잭션의 문제점

- 예전에는 분산 트랜잭션을 이용해서 여러 서비스, DB 메시지 브로커에 걸쳐 데이터 일관성 유지
- NoSQL DB, 메시지 브로커는 분산 트랜잭션 지원 X
- 동기 IPC 형태라서 가용성이 떨어지는 문제점

### 4.1.3 데이터 일관성 유지: 사가 패턴

- MSA 에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘
- 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의
- 사가는 일련의 로컬 트랜잭션
- 시스템 작업은 사가의 첫 번째 단계를 시작
- 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행
- 사가와 ACID 트랜잭션의 차이점
  - ACID 트랜잭션에 있는 격리성(I)가 사가에는 없음
  - 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 함

#### 예제: 주문 생성 사가

- 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거
- 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장
- 메시지 수신자가 일시 불능 상태라면, 메시지 브로커는 다시 메시지를 전달할 수 있을 때까지 메시지를 버퍼링

#### 사가는 보상 트랜잭션으로 변경분을 롤백한다

- 사가는 단계마다 로컬 DB에 변경분을 커밋하므로 자동 롤백은 불가능
- 보상 트랜잭션(compensating transaction)을 미리 작성해야 함
- (n + 1) 번째 사가 트랜잭션이 실패하면 이전 n 개의 트랜잭션을 언두해야 함
- 개념적으로 단계 T<sub>i</sub> 에는 T<sub>i</sub> 의 작용(effect)을 언두하는 보상 트랜잭션 C<sub>i</sub> 가 대응되며, 처음 n 개 단계의 작용을 언두하려는 사가는 각 Ci 를 역순으로 실행하면 됨
- T<sub>1</sub>, ... T<sub>n</sub> 순서로 트랜잭션이 실행되다가 T<sub>n+1</sub> 에서 실패할 경우 T<sub>1</sub>, ... T<sub>n</sub> 을 언두하고 C<sub>n</sub>, ... C<sub>1</sub> 을 순서대로 실행
- 사가는 트랜잭션이 진행하는 반대 방향(C<sub>n</sub>, ... C<sub>1</sub>) 으로 보상 트랜잭션을 실행
- C<sub>i</sub> 와 T<sub>i</sub> 는 순서화(sequencing) 원리가 동일하므로 C<sub>i</sub> 가 끝나면 C<sub>i-1</sub> 실행이 트리거 됨
- 모든 단계에 보상 트랜잭션이 필요한 것은 아님
  - 읽기 전용(read-only) 단계나, 항상 성공하는 단계 다음에 이어지는 단계는 보상 트랜잭션이 필요 없음

## 4.2 사가 편성

- **코레오그래피(coreography)**: 의사 결정과 순서화를 사가 참여자에게 맡깁니다. 사가 참여자는 주로 이벤트 교환 방식으로 통신합니다.
- **오케스트레이션(orchestration)**: 사가 편성 로직을 사가 오케스트레이터에 중앙화합니다. 사가 오케스트레이터는 사가 참여자에게 커맨드 메시지를 보내 수행할 작업을 지시합니다.
- 아주 단순한 사가가 아니라면 가급적 오케스트레이션 방식을 권장

### 4.2.1 코레오그래피 사가

코레오그래피 방식은 사가 참여자가 할 일을 알려 주는 중앙 편성자가 없습니다. 그 대신 사가 참여자가 서로 이벤트를 구독해서 그에 따라 반응하는 것입니다.

#### 주문 생성 사가 구현: 코레오그래피 스타일

- 실패 이벤트가 발행되는 경우 보상 트랜잭션을 가동하여 이미 수행한 작업을 언두

#### 확실한 이벤트 기반 통신

- 코레오그래피 방식으로 사가를 구현할 때 고려해야 할 통신 이슈
  - 사가 참여자가 자신의 DB 를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행하도록 해야 함
    - 트랜잭셔널 메시징을 사용해야 함
  - 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 함
    - 상관관계 ID 가 포함된 이벤트를 발행

#### 코레오그래피 사가의 장단점

- 장점
  - **단순함**: 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행합니다.
  - **느슨한 결합**: 참여자는 이벤트를 구독할 뿐 서로 직접 알지 못합니다.
- 단점
  - **이해하기 어렵다**: 오케스트레이션 사가와 달리, 사가를 어느 한 곳에 정의한 것이 아니라서 여러 서비스에 구현 로직이 흩어져 있습니다. 어떤 사가가 어떻게 작동되는지 개발자가 이해하기 어려운 편입니다.
  - **서비스 간 순환 의존성**: 참여자가 서로 이벤트를 구독하는 특성상, 순환 의존성이 발생하기 쉽습니다.
  - **단단히 결합될 위험성**: 사가 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 합니다.

### 4.2.2 오케스트레이션 사가

- 오케스트레이션 사가에서는 사가 참여자가 할 일을 알려주는 오케스트레이터 클래스(orchestrator class)를 정의
- 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 하며 참여자와 통신
- 사가 단계를 실행하기 위해 해당 참여자가 무슨 일을 해야 하는지 커맨드 메시지에 적어 보냄
- 사가 참여자가 작업을 마치고 응답 메시지를 오케스트레이터에 주면, 오케스트레이터는 응답 메시지를 처리한 후 다음 사가 단계를 어느 참여자가 수행할지 결정

#### 주문 생성 사가 구현: 오케스트레이션 스타일

#### 사가 오케스트레이터를 상태 기계로 모델링

- 상태 기계(state machine)는 상태(state)와 이벤트에 의해 트리거되는 상태 전이(transition)로 구성
- 전이가 발생할 때마다 액션(action)이 일어나는데, 사가의 액션은 사가 참여자를 호출하는 작용
- 상태 간 전이는 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거되고, 로컬 트랜잭션의 상태와 결과에 따라 상태 전이를 어떻게 하고 어떤 액션을 취할지 결정
- 상태 기계는 효율적으로 테스트할 수 있기 때문에 상태 기계를 이용하여 사가를 모델링하면 설계, 구현,테스트를 더 쉽게 진행할 수 있음

#### 사가 오케스트레이션과 트랜잭셔널 메시징

- 오케스트레이션 사가는 DB를 업데이트하는 서비스와 메시지를 발행하는 서비스가 단계마다 있음
- 서비스는 트랜잭셔널 메시지를 사용해서 DB 업데이트와 메시지 발행 작업을 원자적으로 처리

#### 오케스트레이션 사가의 장단점

- 장점
  - **의존 관계 단순화**: 오케스트레이터는 참여자를 호출하지만 참여자는 오케스트레이터를 호출하지 않으므로 순환 의존성이 발생하지 않습니다. 즉, 오케스트레이터는 참여자에게 의존하지만 그 반대는성립하지 않으므로 순환 의존성은 발생하지 않습니다.
  - **낮은 결합도**: 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐, 사가 참여자가 발행하는 이벤트는 몰라도 됩니다.
  - **관심사를 더 분리하고 비즈니스 로직을 단순화**: 사가 편성 로직이 사가 오케스트레이터 한곳에만 있으므로 도메인 객체는 더 단순해지고 ㅈ사ㅣㄴ이 참여한 사가에 대해서는 알지 못합니다.
- 단점
  - 비즈니스 로직을 오케스트레이터에 너무 많이 중앙화 하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수 있음
    - 오케스트레이터가 순서화만 담당하고 여타 비즈니스 로직은 갖고 있지 않도록 설계해야 함

## 4.3 비격리 문제 처리

- 사가는 격리성(I)이 빠져 있음
  - 사가의 한 트랜잭션이 커밋한 변경분을 다른 사가가 즉시 바라볼 수 있음
  - 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기할 수 있음
  - 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있음
- 사가는 ACD 트랜잭션으로 보아야 함
  - **일관성(Atomicity)**: 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 함
  - **일관성(Consistency)**: 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리
  - **지속성(Durability)**: 로컬 DB로 처리
- 격리가 안되면 DB 용어로 비정상(anormaly)이 나타날 가능성이 있음
  - 트랜잭션이 차례대로 실행되지 않는 것철머 데이털르 읽고 쓰게 되는 현상
  - 사가를 동시 실행한 결과와 순차 실행한 결과가 달라질 수 있음
- 비격리는 도저히 ㅛㅇ납되지 못할 문제처럼 보이지만, 실제로 성능 향상을 위해 격리 수준을 낮추어 개발하는 경우 흔함
  - RDBMS 는 격리 수준을 트랜잭션마다 다르게 지정할 수 있고
  - 기본적으로 완전 격리(full isolation)보다 약한 격리 수준을 적용

### 4.3.1 비정상 개요

- 비격리로 인한 비정상
  - **소실된 업데이트(lost updates)**: 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 씀
  - **더티 읽기(dirty reads)**: 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽음
  - **퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads)**: 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제.

#### 소실된 업데이트

- 소실된 업데이트는 한 사가의 변경분을 다른 사가가 덮어 쓸 때 일어남

#### 더티 읽기

- 더티 읽기는 한 사가가 업데이트 중인 데이터를 다른 사가가 읽을 때 발생

### 4.3.2 비격리 대책

- 개발자는 비격리로 인한 비정상을 방지하고 비즈니스에 미치는 영향을 최소화 하는 방향으로 사가를 작성할 의미
- \*_PENDING 상태도 이상 현상을 예방하는 전략 중 하나
  - 일단 \*_PENDING 상태로 두고 시작
  - 시맨틱 락 대책(semantic lock countermeasure)
- 분산 트랜잭션을 사용하지 않는 다중 DB 아키텍처에서 트랜잭션 비격리 문제를 처리하는 방법
  - **시맨틱 락(semantic lock)**: 애플리케이션 수준의 락
  - **교환적 업데이트(commutative updates)**: 업데이트 작업은 어떤 순서로 실행해도 되게끔 설계
  - **비관적 관점(pessimistic view)**: 사가 단계 순서를 재조정하여 비즈니스 리스크를 최소화합니다.
  - **값 다시 읽기(reread value)**: 데이터를 덮어 쓸 떄 그 전에 변경된 내용은 없는지 값을 다시 읽고 확인하여 더티 쓰기(dirty writes)를 방지
  - **버전 파일(version file)**: 순서를 재조정할 수 있게 업데이트를 기록
  - **값에 의한(by value)**: 요청별 비즈니스 위험성을 기준으로 동시성 메커니즘을 동적 선택

#### 사가의 구조

- 사가는 다음 세 가지 트랜잭션으로 구성
  - **보상 가능 트랜잭션(compensatable transaction)**: 보상 트랜잭션으로 롤백 가능한 트랜잭션
  - **피봇 트랜잭션(pivot transaction)**: 사가의 진행/중단 지점. 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행됩니다. 피봇 트랜잭션은 보상 가능 트랜잭션, 재시도 가능한 트랜잭션 그 어느 쪽도 아니지만, 최종 보상 가능 트랜잭션 또는 최초 재시도 가능 트랜잭션이 될 수는 있습니다.
  - **재시도 가능 트랜잭션(retriable transaction)**: 피봇 트랜잭션 직후의 트랜잭션. 반드시 성공합니다.

#### 대책: 시맨틱 락

- 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책
- 레코드가 아직 커밋 전이라서 변경될지 모른다는 표시를 하는 것
- 플래그를 세팅해서 다른 트랜잭션이 레코드에 접근하지 못하게 락을 걸어 놓거나, 다른 트랜잭션이 해당 레코드를 처리할 때 조심하도록 경고
- 플래그는 재시도 가능 트랜잭션(사가 완료) 또는 보상 트랜잭션(사가 롤백)에 의해 해제
- \*_PENDING 상태
- 락도 관리해야 하지만 잠금된 레코드를 어떻게 사가로 처리할지 사례별로(case-by-case) 결정해야 함

#### 대책: 교환적 업데이트

- 업데이트를 교환적(commutative)으로, 즉 어떤 순서로도 실행 가능하게 설계하면 소실된 업데이트 문제를 방지할 수 있음

#### 대책: 비관적 관점

- 비관점 관점(pessimistic view)은 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 사가 단계의 순서를 재조정하는 것

#### 대책: 값 다시 읽기

- 값 다시 읽기(reread value)는 소실된 업데이트를 방지하는 대책
- 사가가 레코드를 업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것
- 값을 읽었더니 변경되었다면 사가를 중단하고 나중에 재시작
- 이 대책은 일종의 낙관적 오프라인 락(Optimistic Offline Lock) 패턴

#### 대책: 버전 파일

- 버전 파일(version file)은 레코드에 수행한 작업을 하나하나 기록하는 대책
- 비교환적(noncommutative) 작업을 교환적(commutative) 작업으로 변환하는 방법
- 순서가 안 맞는 요청을 서비스가 받아 처리하려면, 작업이 도착하면 기록해 두었다가 정확한 순서대로 실행하면 됨

#### 대책: 값에 의한

- 비즈니스 위험성을 기준으로 동시성 메커니즘을 선택하는 것
- 애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지, 아니면 분산 트랜잭션을 쓸지 판단하는 것
  - 위험성이 낮은 요청은 위의 대책이 적용된 사가를, 위험성이 큰 요청은 분산 트랜잭션

## 4.4 주문 서비스 및 주문 생성 사가 설계

### 4.4.1 OrderService 클래스

### 4.4.2 주문 생성 사가 구현

#### CreateOrderSaga 오케스트레이터

#### CreateOrderSagaState 클래스

#### KitchenServiceProxy 클래스

- 프록시 클래스가 반드시 필요한 것은 아님
- 사가가 직접 참여자에게 커맨드 메시지를 보낼 수 있지만, 프록시 클래스를 사용했을 때 이점
  - 프록시 클래스는 타입이 정해진 끝점을 정의하므로 엉뚱한 메시지가 서비스에 전달될 일은 거의 없음
  - 프록시 클래스는 잘 정의된(well-defined) 서비스 호출 API 라서 코드를 이해하고 ㅔㅌ스트 하기 쉬움

### 4.4.3 OrderCommandHandlers 클래스

### 4.4.4 OrderServiceConfiguration 클래스
