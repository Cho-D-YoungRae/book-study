# Chapter 07. 마이크로서비스 쿼리 구현

> MSA 에서 쿼리를 구현하느 방법

- API 조합(composition) 패턴
- CQRS 패턴

## 7.1 API 조합 패턴 응용 쿼리

### 7.1.2 API 조합 패턴 개요

> API 조합 패턴: 여러 서비스에 있는 데이터를 API 를 통해 조회하고 그 결과를 조합하여 쿼리를 구현한다.

- 두 종류의 참여자
  - API 조합기: 프로바이더(provider) 서비스를 쿼리하여 데이터를 조회
  - 프로바이더 서비스: 최종 결과로 반환할 데이터의 일부를 갖고 잇는 서비스
- 이 패턴으로 특정 쿼리 작업을 구현할 수 있을지 여부는 아래 요인 등 다양한 요인에 따라 가변적
  - 데이터가 어떻게 분할되었는지
  - 데이터를 가진 서비스가 어떤 API 기능을 표출하는지
  - 사용 중인 DB 는 어떤 기능을 제공하는지

### 7.1.4 API 조합 설계 이슈

- 어느 컴포넌트를 쿼리 작업의 API 조합기로 선정할 것인가?
- 어떻게 해야 효율적으로 취합 로직을 작성할 것인가?

#### 누가 API 조합기 역할을 맡을 것인가?

- 서비스 클라이언트
  - 클라이언트가 동일한 LAN 에서 실행 중이라면 가장 효율적으로 조회 가능
  - 클라이언트가 방화벽 외부에 있고 서비스가 위치한 네트워크가 느리다면 그리 실용적이지 않음
- 애플리케이션의 외부 API 가 구현된 API 게이트웨이
  - 쿼리 작업이 애플리케이션의 외부 API 중 일부라면 이 방법이 타당
  - 모바일 기기 등 방화벽 외부에서 접근하는 클라이언트가 API 호출 한 번으로 여러 서비스의 데이터를 조회할 수 있기 때문에 효율적
- API 조합기를 스탠드얼론 서비스로 구현
  - 내부적으로 여러 서비스가 사용하는 쿼리 작업이라면 이 방법이 좋음
  - 취합 로직이 너무 복잡해서 API 게이트웨이 일부로 만들기는 곤란하고 외부에서 접근 가능한 쿼리 작업을 구현할 경우에도 좋은 방법

#### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다

- 쿼리 작업의 반응 시간을 최대한 줄이려면 가능한 한 API 조합기가 프로바이더 서비스를 병렬 호출 해야 함

### 7.1.5 API 조합 패턴의 장단점

- 오버헤드 증가
  - 여러 번 요청, 여러 DB 쿼리
  - 네트워크 리소스 더 많이 소모, 애플리케이션 운영 비용 증가
- 가용성 저하 우려
  - 가용성을 높이는 전략
    - 프로바이더 서비스가 불능일 경우 API 조합기가 이전에 캐시한 데이터 반환
    - API 조합기가 미완성된 데이터를 반환
- 데이터 일관성 결여
- API 조합기 패턴은 꽤 많은 쿼리 기능을 쉽게 구현할 수 있는 수단으로 아주 유용
- 효율적으로 구현하기 어려운(가령 거대한 데이터 뭉치를 인-메모리 조인하는) 쿼리 작업은 CQRS 패턴으로 구현하는 편이 바람직

## 7.2 CQRS 패턴

> 커맨드 쿼리 책임 분리 패턴: 여러 서비스에 있는 데이터를 가져오는 쿼리는 이벤트를 이용하여 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지

### 7.2.1 CQRS 의 필요성

- history 쿼리
- 어려운 단일 서비스 쿼리
  - 데이터를 가진 서비스에 쿼리를 구현하는 것이 부적절한 경우
  - 서비스 DB (또는 데이터 모델이) 효율적인 쿼리를 지원하지 않음
- 관심사를 분리할 필요성

### 7.2.2 CQRS 개요

> MSA 에서 쿼리를 구현할 때 흔히 봉착하는 난관

- API 를 조합하여 여러 서비스에 흩어진 데이터를 조회하려면 값비싸고 비효율적인 인-메모리 조인을 해야함
- 데이터를 가진 서비스는 필요한 쿼리를 효율적으로 지원하지 않는 DB에, 또는 그런 형태로 데이터를 저장
- 관심사를 분리할 필요가 있다는 것은 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않다는 뜻

### 7.2.3 CQRS 의 장점

- MSA 에서 쿼리를 효율적으로 구현할 수 있음
- 다양한 쿼리를 효율적으로 구현할 수 있음
- 이벤트 소싱 애플리케이션에서 쿼리가 가능
- 관심사가 더 분리

### 7.2.4 CQRS 의 단점

- 아키텍처가 더 복잡
- 복제 시차(replication lag)를 처리해야 함
  - 커맨드/쿼리 양쪽 API 가 클라이언트에 버전 정보를 전달해서 김빠진 데이터를 분간할 수 있게 만들거나
  - 네이티브 모바일 앱이나 SPA 같은 UI 애플리케이션은 쿼리를 하지 않고 커맨드가 성공하면 자신의 로컬 모델을 업데이트 하는 방법으로 복제 시차를 해소

## 7.3 CQRS 뷰 설계

- DB 를 선정하고 스키마를 설계
- 데이터 접근 모듈을 설계할 떄 멱등한/동시 업데이트 등 다양한 문제를 고려
- 기존 애플리케이션에 새 뷰를 구현하거나 기존 스키마를 바꿀 경우, 뷰를 효울적으로 (재)빌드할 수 있는 수단을 강구
- 뷰 클라이언트에서 복제 시차를 어떻게 처리할지 결정해야 함

### 7.3.1 뷰 DB 선택

|~가 필요하면|~를 사용한다|예시|
|---|---|---|
|JSON 객체를 PK 로 검색|문서형 스토어(MonhoDB, DynamoDB), 키-값 스토어(레디스)|고객별 MongoDB 문서로 주문 이력 관리|
|쿼리 기반의 JSON 객체 검색|문서형 스토어|MongoDB, MynamoDB 로 고객 뷰 구현|
|텍스트 쿼리|텍스트 검색 엔진(엘라스틱서치)|주문별 엘라스틱서치 문서로 주문 텍스트 검색 구현|
|그래프 쿼리|그래프 DB(Neo4j)|고객, 주문, 기타 데이터의 그래프로 부정 탐지 구현|
|전통직인 SQL 리포팅/BI|관계형 DB|표준 비즈니스 리포트 및 분석|

#### 업데이트 작업 지원

뷰 데이터 모델에서는 쿼리뿐만 아니라 이벤트 핸들러가 실행할 업데이트 작업 역시 효율적으로 구현되어야 함

### 7.3.2 데이터 접근 모듈 설계

- 동시성 처리
- 멱등한 이벤트 핸들러
- 클라이언트 애플리케이션이 최종 일관된 뷰를 사용할 수 있다

### 7.3.3 CQRS 뷰 추가 및 업데이트

## 7.4 CQRS 뷰 구현: AWS DynamoDB 응용

### 7.4.2 DynamoDB 데이터 모델링 및 쿼리 설계

다른 NoSQL DB 처럼 DynamoDB 도 데이터 접근 능력이 RDBMS 에 훨씬 못 미치는 수준이기 때문에 데이터를 어떻게 저장하면 좋을지 잘 설계해야 함

- 테이블 설계
- 쿼리 전용 인덱스 정의
- 쿼리 구현
- 쿼리 결과 페이지네이션
- 주문 업데이트
- 중복 이벤트 감지
