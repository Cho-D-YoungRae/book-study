# Chapter 03. 프로세스 간 통신

## 3.1 마이크로서비스 아키텍처 IPC 개요

### 3.1.1 상호 작용 스타일

- 서비스 API 에 알맞은 IPC 를 선택하기 전에 클라이언트/서비스 간 상호 작용 스타일을 잘 살펴보면, 요건에서 벗어나는 일 없이 특정 IPC 기술의 세부 내용에 빠져 헤매는 일을 방지할 수 있음
- 상호 작용 스타일의 선택
  - 전체 애플리케이션의 가용성에 영향
  - 적합한 통합 테스트 전략을 수립하는 데에도 도움
- 클라이언트/서비스 상호 작용 스타일
  - 일대일/일대다 여부
    - 일대일(one-to-one): 각 클라이언트 요청은 정확히 한 서비스가 처리
      - 요청/응답(request/response): 클라이언트는 서비스에 요청을 하고 응답을 기다립니다. 클라이언트는 응답이 제떄 도착하리라 기대하고 대기 도중 블로킹할 수 있습니다. 결과적으로 서비스가 서로 강하게 결합되는 상호작용 스타일입니다.
      - 비동기 요청/응답(asynchronous request/response): 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답합니다. 클라이언트는 대기 중에 블로킹하지 않고, 서비스는 오랫동안 응답하지 않을 수 있습니다.
    - 일대다(one-to-many): 각 클라이언트 요청을 여러 서비스가 협동하여 처리
      - 발행/구독(publish/subscribe): 클라이언트는 알림 메시지를 발행하고, 여기에 관심있는 0개 이상의 서비스(즉, 관심 있는 서비스가 없는 경우도 있음)가 메시지를 소비합니다.
      - 발행/비동기 응답(publish/async response): 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다립니다.
  - 동기/비동기 여부
    - 동기(synchronous): 클라이언트는 서비스가 제시간에 응답하리라 기대하고 대기 도중 블로킹 가능
    - 비동기(asynchronous): 클라이언트가 블로킹하지 않음. 응답은 즉시 전송되지 않아도 됨.

|서비스|작업|협동자|
|---|---|---|
|동기|요청/응답|-|
|비동기|비동기 요청/응답, 단방향 알림| 발행/구독, 발행/비동기 응답|

### 3.1.2 마이크로서비스 API 정의

### 3.1.3 API 발전시키기

- 마이크로서비스 애플리케이션은 클라이언트를 다른 서비스 팀이 개발한 경우가 대부분이기 때문에 서비스 API 를 변경하기 어려움

#### 시멘틱 버저닝

- **시맨틱 버저닝 명세(Semvers, Semantic Versioning specification)**: API 버저닝에 관한 지침서
- 원래 소프트웨어 패키지의 버저닝 용도로 쓰였지만, 분산시스템의 API 버저닝에도 사용할 수 있음

#### 하위 호환되는 소규모 변경

- 옵션 속성을 요청에 추가
- 속성을 응답에 추가
- 새 작업을 추가

#### 중대한 대규모 변경

- 경우에 따라서느 매우 중요한, 기존 버전과 호환이 안 되는 변경을 API 에 적용해야 할 때가 있음
- 일시에 클라이언트를 강제로 업그레이드하는 것은 불가하므로 일정 기간 동안 서비스는 신구 버전 API 를 모두 지원 해야 함
- HTTP 기반의 REST API 라면 URL 에 메이저 버전 번호를 삽입 가능
  - **예**: /v1, /v2, ...
- HTTP 컨텐트 협상(content negotiation)을 이용해서 MIME 타입 내부에 버전 번호를 끼워 넣는 방법도 있음

### 3.1.4 메시지 포맷

- 대부분의 메시지는 데이터를 담고 있기 떄문에 데이터 포맷은 중요한 설계 결정 항목
- IPC 효율, API 사용성, 발전성(evolvability) 에도 영향을 미침
- 메시징이나 HTTP 를 사용하려면 메시징 포맷을 선택, gRPC 같은 IPC 는 메시지 포맷이 정해져 있음
- 어느 프로그래밍 언어로 마이크로서비스를 작성하더라도 나중에 다른 언어를 사용해서 작성하게 될 수 있기 때문에 범언어적(cross-language) 메시지 포맷을 선택하는 것이 중요
  - **예**: 자바 직렬화(Java serialization)는 자바에 국한된 기술이므로 사용 X
- 크게 텍스트와 이진 포맷으로 분류

#### 텍스트 메시지 포맷

> JSON, XML 등

- 사람이 읽을 수 있고 자기 서술적(self describing, 그 자체만으로도 의미가 분명한) 장점
- 메시지 컨슈머는 자신이 관심 있는 값만 골라 쓰고 나머지는 그냥 무시하면 되므로 메시지 스키마가 자주 바뀌어도 하위 호환성은 쉽게 보장
- 메시지가 다소 길다는 단점 (특히 XML)
  - 모든 메시지에 속성값 이외에 속성명이 추가되는 오버헤드
  - 덩키가 큰 메시지는 텍스트를 파싱하는 오버헤드
  - 효율/성능이 중요한 경우는 이진 포맷을 고려

#### 이진 메시지 포맷

> 프로토콜 버퍼, 아브로가 유명

- 메시지 구조 정의에 필요한 타입 IDL 제공하며, 컴파일러는 메시지를 직렬화/역직렬화하는 코드를 생성
  - 서비스를 API 우선 접근 방식으로 설계할 수 밖에 없음
- 아브로 컨슈머는 스키마를 알고 있어야 메시지를 해설할 수 잇기 때문에 API 발전 측면에서는 프로토콜 버퍼가 더 용이

## 3.2 동기 RPI 패턴 응용 통신

- RPI(Remote Procedure Invocation, 원격 프로시저 호출)는 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 회신하는 IPC
- 응답 대기 중에 블로킹하는 클라이언트도 있고, 리액티브한 논블로킹 아키텍처를 가진 클라이언트도 있지만, 어쨋든 메시징으로 통신하는 클라이언트와 달리 응답이 제때 도착하리라 가정

### 3.2.1 동기 RPI 패턴: REST

- REST 는 (거의 항상) HTTP 로 소통하는 IPC

#### REST 성숙도 모델

#### REST API

- REST 는 원래 IDL 이 없었음
- REST API 에도 IDL 이 필요하다는 공감대가 개발자 커뮤니티에 확산되었고 스웨거(Swagger)라는 오픈 소스 프로젝트를 발전시켜 오픈 API 명세(Open API Specification)가 REST API 로서 널리 보급

#### 요청 한 번으로 많은 리소스를 가져오기 어렵다

- REST 리소스는 비즈니스 객체 중심
  - REST API 설계 시 어떻게 하면 클라이언트가 요청 한 번으로 연관된 객체를 모두 가져올 수 있을지
- 이 문제를 해결하는 한 가지 방법은 클라이언트가 리소스를 획득할 때 연관된 리소스도 함께 조회하돌고 API 가 허락하는 것
  - **예**: GET /orders/order-id-1345?expand=consumer
  - 시나리오가 복잡해지면 효율이 떨어지고 구현 시간이 많이 소요
- 이런 까닭에 데이터를 효율적으로 조회할 수 있게 설계된 GraphQL, 넷플릭스 팔코(Netflix Falcor) 등 대체 API 기술이 각광

#### 작업을 HTTP 동사에 매핑하기 어려움

- 동사를 URL 쿼리 매개변수로 지정하는 방법도 있지만 REST 답지 않아서 gRPC 같은 대체 기술이 점점 인기를 끌고 있는 추세

#### REST 의 장단점

- 장점
  - 단순하고 익숙합니다
  - 포스트맨(Postman) 같은 브라우저 플러그인이나 curl 등의 CLI 도구를 사용해서 HTTP API 를 간편하게 테스트할 수 있습니다.
  - 요청/응답 스타일의 통신을 직접 지원합니다.
  - HTTP는 방화벽 친화적(firewall friendly)입니다.
  - 중간 브로커가 피룡하지 않기 때문에 시스템 아키텍처가 단순해집니다.
- 단점
  - 요청/응답 스타일의 통신만 지원합니다.
  - 가용성이 떨어집니다. 중간에서 메시지를 버퍼링하는 매개자 없이 클라이언트/서비스가 직접 통신하기 때문에 교환이 일어나는 동안 양쪽 다 실행 중이어야 합니다.
  - 서비스 인스턴스(들)의 위치(URL)를 클라이언트가 알고 있어야 합니다. 요즘 애플리케이션은 서비스 디스커버리 매커니즘을 이용해서 클라이언트가 서비스 인스턴스 위치를 찾을 수 있으므로 큰 단점은 아닙니다.
  - 요청 한 번으로 여러 리소스를 가져오기 어렵습니다.
  - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 떄가 많습니다.

### 3.2.2 동기 RPI 패턴: gRPC

- HTTP 는 한정된 동사만 지원하기 때문에 다양한 업데이트 작업을 지원하는 REST API 를 설계하기가 쉽지 않음
- gRPC 는 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
- 이진 메시지 기반의 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수 밖에 없음
- 프로토콜 버퍼 기반의 IDL 로 정의
- 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성 가능
- 클라이언트/서버는 프로토콜 버퍼 포맷의 이진 메시지를 HTTP/2를 통해 교환
- 하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성
- 서비스 데피니션은 정적 타입 메서드를 모아 놓은 것
- 단순 요청/응답 RPC는 물론 스트리밍 RPC도 지원
- 프로토콜 버퍼는 간결하고 효율적인 이진 포맷
- 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당
- 메시지 수진자는 자신이 필요한 필드만 추출하고 모르는 필드는 그냥 건너뛸 수 있기 때문에 하위 호환성을 유지하면 API 를 발전시킬 수 있음
- 장점
  - 다양한 업데이트 작업이 포함된 API 를 설계하기 쉽습니다.
  - 특히 큰 메시지를 교환할 떄 콤팩트하고 효율적인 IPC 입니다.
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능합니다.
  - 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능합니다.
- 단점
  - 자바스크립트 클라이언트가 하는 일이 REST/JSON 기반 API 보다 많습니다.
  - 구형 방화벽은 HTTP/2 를 지원하지 않습니다.
- gRPC 는 REST 를 대체할 만한 유력한 방안이지만, REST 처럼 동기 통신하는 메커니즘이라서 부분 실패 문제는 풀어야 할 숙제입니다.

### 3.2.3 부분 실패 처리: 회로 차단기 패턴

> **회로 차단기(circuit breaker) 패턴**: 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간 동안 호출을 즉시 거부하는 RPI 프록시

- 분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재
- 클라이언트/서비스는 모두 개별 프로세스로 동작하기 때문에 서비스가 클라이언트 요청에 제 때 응답하지 못 하거나, 유지보수 또는 기술적 오류 때문에 서비스가 내려갈 수 있음
- 서비스에 과부하가 걸려 응답이 늦어지는 경우도 있음
- 클라이언트는 응답 대기 도중에 블로킹 되기 때문에 서비스 실패는 클라이언트의 클라이언트로 거슬러 올라가면서 전체 시스템의 중단을 초래할 위험도 있음
- 부분 실패가 애플리케이션 전체에 전파되지 않도록 서비스 설계하는 솔루션
  - 무응답 원격 서비스를 처리하기 위해 프록시 같은 견고한 RPI 프록시를 설계
  - 원격 서비스가 실패하면 어떻게 조치해야 할지 결정

#### 견고한 RPI 프록시 설계

- **네트워크 타임아웃**: 응답 대기 중에 무한정 블로킹하면 안 되고 항상 타임아웃을 걸어 둡니다. 이렇게 해야 리소스가 마냥 붙잡히지 않습니다.
- **미처리 요청(outstanding request) 개수 제한**: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정합니다. 이 개수에 이르면 더 이상의 요청은 무의미하므로 즉시 실패 처리하는 것이 타당합니다.
- **회로 차단기 패턴**: 성공/실패 요청 개수를 지켜보다가 에러율이 주어진 임계치를 초과하면 그 이후 시도는 바로 실패 처리합니다. 실패된 요청이 많다는 것은 서비스가 불능 상태고 더 이상의 요청은 무의미하다는 뜻입니다. 타임아웃 시간 이후 클라이언트가 재시도해서 성공하면 회로 차단기는 닫힙니다.

넷플릭스 히스트릭스(Netflix Hystrix)는 이와 같이 다양한 패턴이 구현된 오픈소스 라이브러리

#### 불능 서비스 복구

- 무응답 원격 서비스를 어떻게 복구하면 좋을지는 그때그때 상황에 맞게 판단
- 알기 쉽게 서비스가 클라이언트에 에러를 반환
- 부분 실패 시 미리 정해진 기본값이나 캐시된 응답 등 대체 값을 반환

### 3.2.4 서비스 디스커버리

- 요즘 클라우드 기반의 마이크로서비스 애플리케이션은 네트워크 위치가 동적이라서 이를 식별하는 일이 간단하지 않음

#### 서비스 디스커버리 개요

- 핵심은 애플리케이션 서비스 인스턴스의 네트워크 위치를 DB화한 서비스 레지스트리(service registry)
- 서비스 디스커버리는 주로 다음 두 가지 방법으로 구현
  - 클라이언트/서비스가 직접 서비스 레지스트리와 상호 작용
  - 배포 인프라로 서비스 디스커버리를 처리

#### 애플리케이션 수준의 서비스 디스커버리 패턴 적용

- 서비스 인스턴스는 자신의 네트워크 위치를 서비스 레지스트리에 등록하고, 서비스 클라이언트는 이 서비스 레지스트리로부터 전체 서비스 인스턴스 목록을 가져와 그중 한 인스턴스로 요청을 라우팅
- 두 가지 패턴을 조합한 서비스 디스커버리 방식
  - 자가 등록(self registration) 패턴
  - **클라이언트 쪽 디스커버리 패턴**: 클라이언트는 넘겨 받은 서비스 인스턴스 목록에서 부하 분산 알고리즘을 이용하여 선택 후 요청
- **장점**: 다양한 플랫폼에 서비스가 배포된 경우에도 처리 가능
- **단점**: 사용하는 언어(즉, 프레임워크)에 맞는 서비스 디스커버리 라이브러리가 필요

#### 플랫폼에 내장된 서비스 디스커버리 패턴 적용

- 도커나 쿠버네티스 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 메커니즘이 탑재
- 배포 플랫폼은 DNS 명, 가상 IP(VIP) 주소, VIP 주소로 해석(RESOLVE)되는 DNS 명을 각 서비스 마다 부여
- 다음 두 패턴을 접목 시킨 것
  - **서드파티 등록 패턴**: 서비스가 자신을 서비스 레지스트리에 등록하는 것이 아니라, 배포 플랫폼의 일부인 등록기(registrar)라는 서드파티(third-party)가 이 작업을 대행합니다.
  - **서버 쪽 디스커버리 패턴**: 클라이언트가 서비스 레지스트리를 질의하지 않고 DNS 명을 요청합니다. 그러면 서비스 레지스트리를 쿼리하고 요청을 부하 분산하는 요청 라우터로 해석됩니다.
- **장점**: 서비스 디스커버리 관련 코드는 클라이언트/서비스 어느 쪽에도 없기 때문에 서비스 개발 언어와 상관없이 모든 클라이언트/서비스에 곧바로 적용 가능
- **단점**: 해당 플랫폼으로 배포한 서비스 디스커버리만 지원
- 가능한 한 플랫폼에서 제공되는 서비스 디스커버리를 사용할 것을 권장

## 3.3 비동기 메시징 패턴 응용 통신

- 메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식
- 보통 서비스 간 중개 역할을 하는 메시지 브로커를 사용하지만 서비스가 직접 서로 통신하는 브로커리스(brokerless) 아키텍처도 있음

### 3.3.1 메시징 개요

- 메시지는 메시치 채널(message channel)을 통해 교환

#### 메시지

- 메시지는 헤더(header)와 본문(body)로 구성
- 헤더에는 송신된 데이터에 관한 메타데이터에 해당하는 키/값들로 구성되고 그 밖에 송신자 또는 메시징 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는 반호나 주소(옵션)이 있음
- 본문은 실제로 송신할 텍스트 또는 이진 포맷의 데이터
  - **문서(document)**: 데이터만 포함된 제네릭한 메시지(예**: 커맨드에 대한 응답). 메시지를 어떻게 해석할지는 수신자가 결정.
  - **커맨드(command)**: RPC 요청과 동등한 메시지. 호출할 작업과 매개변수가 지정됨
  - **이벤트(event)**: 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 이벤트는 대부분 도메인 객체의 상태 변활르 나타내는 도메인 이벤트

#### 메시지 채널

- 메시지는 채널을 통해 교환
- 두 종류의 채널
  - **점대점(point-to-point) 채널**: 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달합니다. 앞서 설명한 일대일 상호 작용 스타일의 서비스가 이 채널을 사용합니다(예: 커맨드 메시지).
  - **발행-구독(publish-subscribe) 채널**: 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달합니다. 앞서 설명한 일대다 상호 작용 스타일의 서비스가 이 채널을 사용합니다(예: 이벤트 메시지).

### 3.3.2 메시지 상호작용 스타일 구현

- 3.1.1 절에서 설명한 상호작용 스타일을 모두 지원할 만큼 유연
- 스타일에 따라 메시징으로 직접 구현 가능한 것도 있고, 메시징을 토대로 구현해야 하는 것도 있음

#### 요청/응답 및 비동기 요청/응답

- 메시징은 원래 성격 자체가 비동기적이라서 비동기 요청/응답만 제공하지만 응답을 수신할 때까지 클라이언트를 블로킹할 수도 있음
- 클라이언트/서비스는 한 쌍의 메시지를 주고받는 비동기 요청/응답 스타일로 상호 작용
- 클라이언트는 수행할 작업과 매개변수가 담긴 커맨드 메시지를 <u>서비스가 소유한 점대점 메시징 채널</u>에 보냄
- 서비스는 요청을 처리한 후 그 결과가 담긴 응답 메시지를 <u>클라이언트가 소유한 점대점 채널</u>로 돌려보냄
- 클라이언트는 서비스가 어디로 응답 메시지를 보내야 하는지 알려주고 이렇게 받은 응답 메시지는 요청과 짝이 맞아야 함
  - 클라이언트는 MessageID 및 응답 채널이 헤더에 명시된 커맨드 메시지를 보내고, 서버는 MessageId 와 값이 동일한 CorrelationId 가 포함된 응답 메시지를 응답 채널에 씀
  - 이론적으로 클라이언트가 응답을 수신할 때까지 블로킹할 수는 있지만, 실제로 클라이언트는 응답을 비동기 처리하고 클라이언트 인스턴스 중 하나가 응답을 처리

#### 단방향 알림

- 서비스가 소유한 점대점 채널로 클라이언트가 메시지(커맨드 메시지)를 보내면, 서비스는 이 채널을 구독해서 메시지를 처리하는 구조
- 단방향이므로 서비스는 응답을 반환하지 않음

#### 발행/구독

- 메시징은 발행/구독 스타일의 상호 작용을 기본 지원
- 서비스는 자신이 관심 있는 도메인 객체의 이벤트 채널을 구독

#### 발행/비동기 응답

- 발행/비동기 응답 스타일은 발행/구독과 요청/응답의 엘리먼트를 조합한 고수준의 상호 작용 스타일
- 클라이언트는 응답 채널 해더가 명시된 메시지를 발행/구독 채널에 발행하고 컨슈머는 CorrelationId 가 포함된 응답 메시지를 지정된 응답 채널에 씀

### 3.3.3 메시징 기반 서비스의 API 명세 작성

- 서비스의 비동기 API 명세에는 메시지 채널명, 각 채널을 통해 교환되는 메시지 타입과 포맷을 명시하고, 메시지 포맷은 JSON, XML, 프로토콜 버퍼 등 표준 포맷으로 기술해야 함
- REST, Open API 와 달리 채널 및 메시지 타입은 딱히 정해진 문서화 표준이 없으므로 자유롭게 기술
- 서비스 비동기 API 는 클라이언트가 호출하는 작업과 서비스에 의해 발행되는 이벤트로 구성
- 작업과 이벤트는 문서화하는 방법이 다름

#### 비동기 작업 문서화

- 서비스 작업은 두 가지 상호 작용 스타일 중 하나로 호출 가능
  - **요청/비동기 응답 스타일 API**
    - 서비스의 커맨드 메시지 채널
    - 서비스가 받는 커맨드 메시지의 타입과 포맷
    - 서비스가 반환하는 응답 메시지의 타입과 포맷
  - **단방향 알림 스타일 API**
    - 서비스의 커맨드 메시지 채널
    - 서비스가 받는 커맨드 메시지의 타입과 포맷
- 서비스는 요청/비동기 응답, 단방향 알림 모두 동일한 요청 채널을 사용 가능

#### 발행 이벤트 문서화

- 서비스는 발행/구독 스타일로도 이벤트 발행 가능
- 이런 스타일의 API 명세는 이벤트 채널, 서비스가 채널에 발행하는 이벤트 메시지의 타입과 포맷으로 구성

### 3.3.4 메시지 브로커

- 메시징 기반의 애플리케이션은 대부분 메시지 브로커를 사용
- 서비스가 서로 직접 통신하는 브로커리스 기반의 메시징 아키텍처도 있음
- 일반적으로 브로커 기반의 아키텍처가 더 나음

#### 브로커리스 메시징

- 브로커리스 아키텍처의 서비스는 메시지를 서로 직접 교환
- 장점
  - 송신자가 보낸 메시지가 브로커를 거쳐 수신자로 이동하는 것이 아니라, 송신자에서 수신자로 직접 전달되므로 네트워크 트래픽이 가볍고 지연 시간이 짧음
  - 메시지 브로커가 성능 병목점이나 SPOF(Single Point Of Failure, 단일 장애점)가 될 일이 ㅇ벗음
  - 메시지 브로커를 설정/관리할 필요가 없으므로 운영 복잡도 낮음
- 단점
  - 서비스가 서로의 위치를 알고 있어야 하므로 서비스 디스커버리 메커니즘 중 하나를 사용해야 함
  - 메시지 교환 시 송신자/수신자 모두 실행 중이어야 하므로 가용성 떨어짐
  - 전달 보장(guaranteed delivery) 같은 메커니즘을 구현하기가 더 어려움
- 가용성 저하 및 서비스 디스커버리가 필요한 것은 사실 동기 요청/응답을 사용하는 방식도 별반 다르지 않음

#### 브로커 기반 메시징 개요

- 메시지 브로커는 모든 메시지가 지나가는 중간 지점
- 장점
  - 송신자가 컨슈머의 네트워크 위치를 몰라도 됨
  - 컨슈머가 메시지를 처리할 수 있을 때 까지 메시지 브로커에 메시지를 버퍼링할 수 있음
- 메시지 브로커를 선택할 때 검토 사항
  - **프로그래밍 언어 지원 여부**: 다양한 프로그래밍 언어를 지원할수록 좋습니다.
  - **메시징 표준 지원 여부**: AMQP 나 STOMP 등 표준 프로토콜을 지원하는 제품인가, 아니면 자체 표준만 지원하는 제품인가?
  - **메시지 순서**: 메시지 순서가 유지되는가?
  - **전달 보장**: 어떤 종류의 전달 보장을 하는가?
  - **영속화**: 브로커가 고장 나도 문제가 없도록 메시지를 디스크에 저장하는가?
  - **내구성**: 컨슈머가 메시지 브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된 메시지를 받을 수 있나?
  - **확장성**: 얼마나 확장성이 좋은가?
  - **지연 시간**: 종단 간 지연 시간은 얼마나 되나?
  - **경쟁사 컨슈머**: 경쟁사의 컨슈머를 지원하는가?
- 브로커마다 다 일장일단이 있지만, 메시징 순서 유지 및 확장성은 필수 요건

#### 메시지 브로커로 메시지 채널 구현

|메시지 브로커|점대점 채널|발행-구독 채널|
|---|---|---|
|JMS|큐|토픽|
|아파치 카프카|토픽|토픽|
|AMQP 브로커(예: RabbitMQ)|익스체인지 + 큐|팬아웃 익스체인지, 컨슈머 개별 큐|
|AWS 키네시스|스트림|스트림|
|AWS SQS|큐|-|

#### 브로커 기반 메시징의 장단점

- 장점
  - **느슨한 결합**: 클라이언트는 적절한 채널에 그냥 메시지를 보내는 식으로 요청합니다. 클라이언트는 서비스 인스턴스를 몰라도 되므로 서비스 인스턴스 위치를 알려주는 디스커버리 메커니즘도 필요 없습니다.
  - **메시지 버퍼링**: 메시지 브로커는 처리 가능한 시점까지 메시지를 버퍼링합니다. HTTP같은 동기 요청/응답 프로토콜을 쓰면 교환이 일어나는 동안 클라이언트/서비스 양쪽 모두 가동 중이어야 하지만 메시징을 쓰면 컨슈머가 처리할 수 있을 떄까지 그냥 큐에 메시지가 쌓입니다. 덕분에 온라인 상점에서 주문 이행 시스템이 느려지거나 불능 상태에 빠지는 사고가 발생해도 컨슈머는 주문을 계속 접수할 수 있습니다. 그냥 언젠가는 처리되겠거니 간주하고 메시지를 차곡차곡 쌓아 두는 것입니다.
  - **유연한 통신**: 메시징은 지금까지 설명한 모든 상호 작용 스타일을 지원합니다.
  - **명시적 IPC**: RPC 메커니즘은 원격 서비스가 마치 자신이 로컬 서비스인 양 호출을 시도합니다. 하지만 물리 법칙상으로도 그렇고 부분 실패할 가능성이 있기 때문에 사실 서비스와는 완전히 다릅니다.
- 단점
  - **성능 병목 가능성**: 메시지 브로커가 성능 병목점이 될 위험이 있습니다. 하지만 다행히 요즘 메시지 브로커는 대부분 확장이 잘 되도록 설계되었습니다.
  - **단일 장애점 가능성**: 메시지 브로커는 가용성이 높아야 합니다. 그렇지 않으면 시스템의 신뢰성에 흠이 갈 수 있겠죠. 다행히 요즘 브로커는 대부분 고가용성이 보장되도록 설계되었ㅅ브니다.
  - **운영 복잡도 부가**: 메시징 시스템 역시 설치, 구성, 운영해야 할 시스템 컴포넌트입니다.

### 3.3.5 수신자 경합과 메시지 순서 유지

- 요즘 메시지 브로커는 샤딩된 채널을 이용
- 샤딩된 채널은 복수의 샤드로 구성되며, 각 샤드는 채널처럼 작동합니다.
- 송신자는 메시지 헤더에 샤드 키(보통 무작위 문자열 또는 바이트)를 지정합니다. 메시지 브로커는 메시지를 샤드 키별로 샤드/파티션에 배정합니다.
- 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급합니다(아파치 카프카 용어로 컨슈머 그룹). 메시지 브로커는 각 샤드를 하나의 수신자에 배정하고, 수신자가 시동/종료하면 샤드를 재배정합니다.
- orderId 를 주문 이벤트 메시지의 샤드 키로 지정하면 주문별 이벤트는 각각 동일한 샤드에 발행되고 어느 한 컨슈머 인스턴스만 메시지를 읽기 때문에 미시지 처리 순서가 보장

### 3.3.6 중복 메시지 처리

- 메시지 브로커가 각 메시지를 꼭 한 번만 전달하면 좋겠지만, 그렇게 강제하려면 그만큼 값비싼 대가를 치러야 합니다. 그래서 메시지 브로커는 보통 적어도 한 번 이상 메시지를 전달하겠노라 약속합니다.
- 시스템이 정상일 때 '적어도 한 번 전달'을 보장하는 메시지 브로커는 각 메시지를 한 번만 전달
- 클라이언트나 네트워크 또는 브로커 자신이 실패할 경우, 같은 메시지를 여러 번 전달할 수 있음
- 중복 메시지를 처리하는 방법
  - 멱등한 메시지 핸들러 작성
  - 메시지를 추적하고 중복을 솎아 냄

#### 멱등한 메시지 핸들러 작성

- 애플리케이션의 메시지 처리 로직이 멱등하면 중복 메시지는 전혀 해롭지 않음
- 그러나 이렇게 멱등한 애플리케이션 로직은 실제로 별로 없음
  - 중복 메시지와 순서가 안 맞는 메시지는 오류를 일으키기 때문에 중복 메시지를 솎아 내는 메시지 핸들러 필요

#### 메시지 추적과 중복 메시지 솎아 내기

- 컨슈머가 메시지 ID 를 이용하여 메시지 처리 여부를 추적하면서 중복 메시지를 솎아 내면 간단히 해결
- 이를테면 컨슈머가 소비하는 메시지 ID를 무조건 DB 테이블에 저장
- 컨슈머는 PROCESSED_MESSAGES 라는 전용 테이블에 메시지 ID 가 포함된 로우를 삽입
- 전용 테이블 대신 일반 애플리케이션 테이블에 메시지 ID 를 기록하는 방법도 있음
  - 한 DB 트랜잭션으로 두 테이블을 업데이트하는 일이 불가능한, 트랜잭션 모델이 제한적인 NoSQL DB 에서 유용

### 3.3.7 트랜잭셔널 메시징

- 서비스는 보통 DB 를 업데이트하는 트랜잭션의 일부로 메시지를 발행
- DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않으면, DB 업데이트 후 메시지는 아직 전송되지 않은 상태에서 서비스가 중단될 수 있기 때문에 문제가 됨

#### DB 테이블을 메시지 큐로 활용

- RDBMS 기반의 애플리케이션이라면 DB 테이블을 임시 메시지 큐로 사용하는 `트랜잭셔널 아웃 박스 패턴`이 가장 알기 쉬운 방법
  - 메시지를 보내는 서비스에 OUTBOX 라는 DB 테이블을 만들고
  - 비즈니스 객체를 생성, 수정, 삭제하는 DB 트랜잭션의 일부로 OUTBOX 테이블에 메시지 삽입
  - 로컬 ACID 트랜잭션이기 때문에 원자성은 자동 보장
  - OUTBOX 테이블은 임시 메시지 큐 역할
  - 메시지 릴레이(relay, 중계기)는 OUTBOX 테이블을 읽어 메시지 브로커에 메시지를 발행하는 컴포넌트
- NoSQL DB 도 방법 비슷
  - DB 에 레코드로 적재된 비즈니스 엔터티에 발행할 메시지 목록을 가리키는 속성이 있는데, 서비스가 DB 엔터티를 업데이트할 떄 바로 이 목록에 메시지를 덧붙이면 됨
  - 단일 DB 작업이므로 원자적이지만, 문제는 이벤트를 가진 비즈니스 엔터티를 효과적으로 찾아 발행하는 일

#### 이벤트 발행: 폴링 발행기 패턴

- 메시지 릴레이로 테이블을 폴링해서 미발행 메시지를 조회하는 것
- 메시지 릴레이는 이렇게 조회한 메시지를 하나씩 각자의 목적지 채널로 모내서 메시지 브로커에 발행하고, OUTBOX 테이블에서 메시지를 삭제
- DB 폴링은 규모가 작을 경우 쓸 수 있는 단순한 방법
- DB 를 자주 폴링하면 비용이 유발
- NoSQL DB 는 쿼리 능력에 따라 사용 가능 여부 결정
  - 애플리케이션이 OUTBOX 테이블을 쿼리하는 대신 비즈니스 엔터티를 쿼리해야 하는 경우도 있는데, 이런 일이 효율적으로 가능할 수도 있고 불가능할 수도 있기 때문
- 이런 단점과 한계로 인해 (어떤 경우에는 유용하지만) DB 트랜잭션 로그 테일링이 좀 더 정교하고 성능이 좋은 방법

#### 이벤트 발행: 트랜잭션 로그 테일링 패턴

- 메시지 릴레이로 DB 트랜잭션 로그(커밋 로그)를 테일링(tailing)하는 방법

### 3.3.8 메시징 라이브러리/프레임워크

- 서비스가 메시지를 주고받으려면 라이브러리가 필요
- 메시지 브로커의 클라이언트 라이브러리를 직접 사용했을 때의 문제
  - 메시지 브로커 API 에 메시지를 발행하는 비즈니스 로직이 클라이언트 라이브러리와 결합됩니다.
  - 메시지 브로커의 클라이언트 라이브러리는 대부분 저수준이고 메시지를 주고받는 코드가 꽤 긴 편입니다.
  - 메시지 브로커의 클라이언트 라이브러리는 기본적인 메시지 소통 수단일 뿐, 고수준의 상호 작용 스타일은 지원하지 않습니다.
- 따라서 저수준 세부를 감추고 고수준의 상호 작용 스타일을 직접 지원하는 고수준 라이브러리 또는 프래임워크 필요
- 이벤추에이트 트램 프레임워크에 구현되어 있는 두 가지 중요한 메커니즘
  - 트랜잭셔널 메시징: 메시지를 DB 트랜잭션의 일부로 발행
  - 중복 메시지 감지: 이벤추에이트 트램의 메시지 컨슈머는 중복 메시지를 솎아 냅니다.

#### 기초 메시징

#### 도메인 이벤트 발행

#### 커맨드/응답 메시징

## 3.4 비동기 메시징으로 가용성 개선

### 3.4.1 동기 통신으로 인한 가용성 저하

- 동기 통신은 호출한 서비스가 응답할 때까지 HTTP 클라이언트가 마냥 기다려야 하므로 가용성이 저하

### 3.4.2 동기 상호 작용 제거

#### 비동기 상호 작용 스타일

- 모든 트랜잭션은 비동기 상호 작용 스타일로 처리하는 것이 좋음
- 어느 쪽도 응답을 대기하며 블로킹되지 않음
- 메시지가 소비되는 시점까지 메시지 브로커가 메시지를 버퍼링하기 때문에 매우 탄력적
- 그러나 REST 같은 동기 프로토콜을 사용하기 때문에 요청 즉시 응답해야 하는 외부 API 를 가진 서비스도 있을 것 인데, 이런 경우 데이터를 복제하면 가용성을 높일 수 있음

#### 데이터 복제

- 서비스 요청 처리에 필요한 데이터의 레플리카를 유지하는 방법
- 데이터 레플리카는 데이터를 소유한 서비스가 발행하는 이벤트를 구독해서 최신 데이터를 유지할 수 있음
- 데이터 복제는 경우에 따라 유용
- 대용량 데이터의 레플리카를 만드는 것은 비효율적
- 다른 서비스가 소유한 데이터를 업데이트 하는 문제도 데이터 복제만으로는 해결 불가능

#### 응답 반환 후 마무리

- 요청 처리 도중 동기 통신을 제거하려면
  - 로컬에서 가용한 데이터만 갖고 요청을 검증
  - 메시지를 OUTBOX 테이블에 삽입하는 식으로 DB 업데이트
  - 클라이언트에 응답을 반환
- 요청을 완전히 처리하기 전에 클라이언트에 응답하는 서비스는 클라이언트 코드가 조금 복잡한 편
  - 가령 주문 서비스는 응답 반환 시 새로 생성된 주문 상태에 관한 최소한의 정보만 보장
  - 주문 생성 직후에 반환되므로주문 검증이나 소비자 신용카드 승인은 아직 완료 전
  - 클라이언트 입장에서 주문 생성 성공 여부를 알아내려면 주기적으로 폴링하거나 알림 메시지를 보내주어야 함
