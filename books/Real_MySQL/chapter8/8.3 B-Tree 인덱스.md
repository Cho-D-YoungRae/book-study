# 8.3 B-Tree 인덱스

## 8.3.1 구조 및 특성

- `루트 노드(Root node)`: 최상위
- `리프 노드(Leaf node)`: 최하위
- `브랜치 노드(Branch node)`: 루트 노드도 리프 노드도 아닌 중간의 노드
- `리프 노드`는 실제 데이터 레코드를 찾아가기 위한 주솟값을 가지고 있음
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야함

## 8.3.2 B-Tree 인덱스 키 추가 및 삭제

### 8.3.2.1 인덱스 키 추가

- B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)에 비용이 많이 듬
  - 아래와 같은 작업으로 인해
  - 적절한 위치 검색
  - 리프 노드가 꽉 찬 경우 분리
- InnoDB 스토리지 엔진은 필요하다면 인덱스 키 추가 작업 지연 가능
  - 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기 때문에 즉시 B-Tree에 추가 혹은 삭제

### 8.3.2.2 인덱스 키 삭제

- 삭제 마크만 하면 작업 완료
- 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용

### 8.3.2.3 인덱스 키 변경

- 먼저 키 값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리
- InnoDB 스토리지 엔진을 사용하는 테이블의 경우 체인지 퍼버를 활용해 지연처리 가능

### 8.3.2.4 인덱스 키 검색

- UPDATE 나 DELETE 를 처리하기 위해 항상 해당 레코드를 먼저 검색해야 할 경우에도 사용
- 일치 조건 또는 앞부분 일치 조건에서 사용 가능
- 부등호 비교 조건 사용 가능
- 인덱스 키 값 뒷부분 검색 사용 불가능
- 인덱스 키 값 변형 후 비교 사용 불가능
- InnoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있어서 UPDATE나 DELETE 문장이 실행될 때 테이블에 적절히 사용할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠금

## 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

- 칼럼의 크기
- 레코드의 건수
- 유니크한 인덱스 키 값의 개수

### 8.3.3.1 인덱스 키 값의 크기

- InnoDB 스토리지 엔진은 디스크에 데이터를 저장하는 기본 단위를 페이지(Page) 또는 블록(Block) 이라고 함
- B-Tree 는 자식 노드의 개수가 가변적
- 인덱스의 페이지 크기와 키 값의 크기에 따라 결정
- 인덱스의 한 페이지당 페이지 크기 만큼 저장 가능
- 인덱스를 구성하는 키 값의 크기가 커지면 디스크로부터 읽어야 하는 횟수가 늘어나고(데이터가 많아짐에 따라 인덱스 페이지가 더 빠르게 증가하므로), 그 만큼 느려짐
- InnoDB의 버퍼 풀이나 MyISAM의 키 캐시 영역은 크기가 제한적이므로 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수 줄어듬

### 8.3.3.2 B-Tree 깊이

- 직접 제어는 불가능
- 인덱스 키 값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 그 때문에 같은 레코드 건수라 하더라도 B-Tree의 깊이(Depth)가 커져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미
- 인덱스 키 값의 크기는 가능한 작게 만드는 것이 좋음

### 8.3.3.3 선택도(기수성)

- 모든 인덱스 키 값 중 유니크한 값의 수
- 인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠리게 처리됨
- 선택도가 좋지 않다고 하더라도 **정렬**이나 **그루핑**과 같은 작업을 위해 인덱스를 만드는 것이 좋은 경우도 많음

### 8.3.3.4 읽어야 하는 레코드의 건수

- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측
- 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적

## 8.3.4 B-Tree 인덱스를 통한 데이터 읽기

### 8.3.4.1 인덱스 레인지 스캔

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

- 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계 X
- 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 필요한 레코드의 시작 지점을 찾을 수 있음
- 일단 시작해야할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 됨
- 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우 레코드 한 건 한 건 단위로 랜덤 I/O 발생

#### 인덱스 레인지 스캔 3단계

1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색(Index seek)이라고 한다.
2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽는다. 이 과정을 인덱스 스캔(Index scan)이라고 한다. (1번과 2번 합쳐서 인덱스 스캔으로 통칭하기도 한다.)
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.

#### 커버링 인덱스

- 쿼리가 필요로 하는 데이터에 따라 인덱스 레인지 스캔 3단계 중 3번 과정은 필요하지 않을 수 있음
- 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 상당히 줄어들고 성능은 그만큼 빨라짐

### 8.3.4.2 인덱스 풀 스캔

- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우
  - ex) 인덱스는 (A, B, C) 칼럼 순서로 되어있지만, 조건절은 B 칼럼이나 C 칼럼으로 검색하는 경우
- 일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우 주로 이 방식이 사용
- 인덱스 레인지 스캔보다는 빠르지 않지만, 테이블 풀 스캔보다는 효율적

#### 인덱스 풀스캔 처리 방식

1. 인덱스 리프 노드의 제일 앞 또는 제일 뒤로 이동
2. 인덱스의 리프 노드를 연결하는 LinkedList 를 따라서 처음부터 끝까지 스캔

### 8.3.4.3 루스 인덱스 스캔

- 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것 (앞의 인덱스 레인지 스캔과 인덱스 풀 스캔은 '타이트 인덱스 스캔'으로 볼 수 있음)
- 인덱스 레인지 스캔과 비슷하지만 중간에 필요치 않은 인덱스 키 값은 무시(SKIP)하고 다음으로 넘어가는 형태로 처리
- 일반적으로 `GROUP BY` 또는 `MAX()` `MIN()` 함수에 대해 최적화를 하는 경우 사용

#### 루스 인덱스 스캔 동작 방식

```sql
-- (dept_no, emp_no) 로 인덱스 생성돼 있음
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

- dept_no 그룹별로 첫 번째 레코드의 emp_no 값만 읽으면 됨
- 조건에 만족하지 않는 레코드는 무시

### 8.3.4.4 인덱스 스킵 스캔

- 루스 인덱스 스캔(Loose index scan)기능도 비슷한 최적화를 수행하지만 이는 GROUP BY 작업을 처리하기 위해 인덱스를 사용하는 경우에만 적용 가능
- 인덱스 스킵 스캔은 WHERE 조건절의 검색을 위해 사용 가능

#### 인덱스 스킵 스캔 작동 방식

```sql
-- INDEX ix_gender_birthdate (gender, birth_date)
SELECT gender, birth_date FROM employees WHERE birth_date >= '1965-02-01';

-- 위 쿼리는 인덱스 스킵 스캔 시 아래와 같이 실행됌
SELECT gender, birth_date FROM employees WHERE gender = 'M' AND birth_date >= '1965-02-01';
SELECT gender, birth_date FROM employees WHERE gender = 'F' AND birth_date >= '1965-02-01';
```

- gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리

#### 단점

- WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
  - MySQL 서버의 옵티마이저가 개선되면 충분히 해결될 것으로 보임

## 8.3.5 다중 칼럼(Multi-column) 인덱스

- 2개 이상의 칼럼이 연결됐다고 해서 'Concatenated Index' 라고도 함
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬
  - 이후 칼럼도 그 앞 칼럼에 의존해서 정렬
- 아중 칼럼 인덱스에서는 인덱스 내에서 각 칼럼의 위치(순서)가 중요

## 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스를 생성할 때 설정한 정렬 규칙에 따라서 인덱스의 키 값은 항상 오름차순이나 내림차순으로 정렬되어 저장
  - 해당 방향으로만 읽을 수 있는 것은 아님
- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행 계획에 따라 결정

### 8.3.6.1 인덱스의 정렬

- 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순 또는 내림차순으로 설정 가능

```sql
CREATE INDEX ix_teamname_userscore ON employees (team_name ASC, user_score DESC);
```

#### 8.3.6.1.1 인덱스 스캔 방향

- 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용하는 시점에 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있음

#### 8.3.6.1.2 내림차순 인덱스

##### InnoDB에서 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느린 이유

- 페이지 잠금이 인덱스 정순 스캔(Forward index scan)에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

##### 서비스 요건에 맞게 어떤 정렬 순서의 인덱스를 선택할지

- `ORDER BY ... DESC` 하는 쿼리가 소량의 레코드에 드물게 실행되는 경우라면 내림차순 인덱스를 굳이 고려할 필요 X
- 하지만 위와 같은 쿼리가 많은 레코드를 조회하면서 빈번하게 실행된다면 오름차순 인덱스보다는 내림차순 인덱스가 더 효율적
- 많은 쿼리가 인덱스의 앞쪽만 또는 뒤쪽만 집중적으로 읽어서 특정 페이지 잠금이 병목이 될 것으로 예상된다면 쿼리에서 자주 사용되는 정렬 순서대로 인덱스를 생성해서 잠금 병목 현상 완화 가능

## 8.3.7 B-Tree 인덱스의 가용성과 효율성

> 쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지

### 8.3.7.1 비교 조건의 종류와 효율성

> 다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교(=)인지 아니면 크다(>) 또는 작다(<) 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

```sql
SELECT * FROM dept_emp WHERE dept_no = 'd002' AND emp_no >= 10114;
```

#### Case A. INDEX(dept_no, emp_no)

- `dept_no = 'd002' AND emp_no >= 10114` 인 레코드를 찾고 그 이후 `dept_no = 'd002'` 가 아닐 때까지 인덱스를 그냥 쭉 읽기만 하면 됨
- 꼭 필요한 비교 작업만 수행
- `작업 범위 결정 조건`: 작업의 범위를 결정하는 조건

#### Case A. INDEX(emp_no, dept_no)

- `emp_no >= 10114 AND dept_no = 'd002'` 인 레코드를 찾고, 그 이후 모든 레코드에 대해 `dept_no = 'd002'` 인지 비교하는 과정 필요
- 불필요한 비교 작업도 수행
- `필터링 조건`, `체크 조건`: 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건
- emp_no 칼럼만 `작업 범위 결정 조건` 이고, dept_no 칼럼은 `필터링 조건` 으로 사용됨

#### 결론

- `작업 범위 결정 조건` 은 많으면 많을수록 쿼리 처리 성능을 높임
- `필터링 조건`은 많다고 해서 쿼리의 처리 성능을 높이지는 못하고(최종적으로 가져오는 레코드는 작게 만들지 몰라도), 오히려 쿼리 실행을 더 느리게 많들 떄가 많음

### 8.3.7.2 인덱스의 가용성

- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서(Left-most) 오른쪽 값이 정렬
- 하나의 칼럼 내에서 뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 적용
- 하나의 칼럼으로 검색해도 값의 왼쪽 부분이 없으면 인덱스 레인지 스캔 방식의 검색 불가능
- 다중 칼럼 인덱스에서도 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔 사용 불가능

#### Case 1. INDEX(first_name)

```sql
SELECT * FROM employees WHERE first_name LIKE '%mer';
```

- 인덱스 레인지 스캔 방식으로 인덱스 사용 불가능
- first_name 칼럼에 저장된 값의 왼쪽부터 한 글자씩 비교해 가면서 일치하는 레코드를 찾아야 하는데, 조건절에 주어진 상숫값('%mer')에는 왼쪽 부분이 고정되지 않음

#### Case 1. INDEX(dept_no, emp_no)

```sql
SELECT * FROM dept_emp WHERE emp_no > 10144;
```

- 인덱스가 (dept_no, emp_no) 칼럼 순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no 조건 없이 emp_no 값으로만 검색하면 인덱스 효율적으로 사용 불가능
- dept_no 칼럼에 대해 먼저 정렬한 후, emp_no칼럼값으로 정렬돼 있기 때문

### 8.3.7.3 가용성과 효율성 판단

- 다른 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장

#### B-Tree 인덱스 사용 불가능한 경우

> B-Tree 인덱스 특성상 다음 조건에서는 사용할 수 없다. 여기서 사용할 수 없다는 것은 `작업 범위 결정 조건`으로 사용할 수 없다는 것을 의미하며, 경우에 따라서는 `체크 조건` 으로 인덱스를 사용할 수는 있다.

- NOT-EQUAL 로 비교된 경우(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
- LIKE '%??'(뒷 부분 일치) 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연싼자로 인덱스 칼럼이 변형된 후 비교된 경우
  - `... WHERE SUBSTRING(column, 1, 1) = 'X'`
  - `... WHERE DAYOFMONTH(column) = 1`
- NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우
  - `... WHERE column = deterministic_function()`
  - NOT-DETERMINISTIC 속성의 스토어드 함수: 비교가 실행되는 레코드마다 이 Stored routine을 매번 새로 호출해서 비교를 실행 -> 즉, 함수 호출의 결과 값이 Cache 되지 않고, 비교되는 레코드 건수만큼 함수 호출 발생
- 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
- 문자열 데이터 타입의 콜레이션이 다른 경우
  - `WHERE utf8_bin_char_column = euckr_bin_char_column`

#### 다중 칼럼으로 만들어진 인덱스 사용 조건

```sql
INDEX ix_test ( column_1, column_2, column_3, ..., column_n )
```

##### 작업 범위 결정 조건으로 인덱스를 사용하지 못 하는 경우

- column_1 칼럼에 대한 조건이 없는 경우
- column_1 칼럼의 비교 조건이 위의 인덱스 사용 불가 조건 중 하나인 경우

##### 작업 범위 결정 조건으로 인덱스를 사용하는 경우

> 2 < i < n

- column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태(= or IN)로 비교
- column_i 칼럼에 대해 다음 연산자 중 하나로 비교
  - 동등 비교(= or IN)
  - 크다 작다 형태(> or <)
  - LIKE로 좌측 일치 패턴(LIKE '??%')
