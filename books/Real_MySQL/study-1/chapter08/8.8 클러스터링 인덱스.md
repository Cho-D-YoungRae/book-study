# 8.8 클러스터링 인덱스

- 테이블의 레코드를 비슷한 것(프라이머리 키를 기준으로)들끼리 붂어서 저장하는 형태로 구현
- 주소 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안
- InnoDB스토리지 엔진에서만 지원

## 8.8.1 클러스터링 인덱스

- 프라이머리 키에 대해서만 적용
- 프라이머리 키 값에 의해 레코드의 저장 위치가 결정
  - 인덱스 알고리즘이라기보다 테이블 레코드의 저장 방식이라고도 볼 수 있음
- 프라이머리 키 값 자체에 대한 의존도 상당히 큼
- 키 기반 검색 매우 빠름
- 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느림
- 구조 자체는 B-Tree 와 비슷
- 리프 노드에 레코드의 모든 칼럼이 같이 저장돼 있음
- 프라이머리 키가 없는 InnoDB 테이블은 어떻게 클러스터링 테이블로 구성될까?
  - 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
  - NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
  - 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택

## 8.8.2 세컨더리 인덱스에 미치는 영향

- 모든 세컨더리 인덱스는 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있음

## 8.8.3 클러스터링 인덱스의 장점과 단점

장점은 빠른 읽기(SELECT), 단점은 느린 쓰기(INSERT, UPDATE, DELETE)

### 장점

- 프라이머리 키(클러스터링 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)
- 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 떄문에 인덱스만으로 처리될 수 있는 경우가 많음(이를 커버링 인덱스라고 함)

### 단점

- 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
- 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느림
- INSERT할 때 플아ㅣ머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE 하고 INSERT 하는 작업이 필요하기 때문에 처리 성능이 느림

## 8.8.4 클러스터링 테이블 사용시 주의 사항

### 8.8.4.1 클러스터링 인덱스 키의 크기

- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 프라이머리 키(클러스터링 키)값을 포함
  - 프라이머리 키의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커짐
- 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요해지므로 InnoDB 테이블의 프라이머리 키는 신중하게 선택

### 8.8.4.2 프라이머리 키는 AUTO_INCREMENT보다는 업무적인 칼럼으로 생성(가능한 경우)

- 이 값에 의해 레코드 위치가 결정됨
- 프라이머리 키로 검색하는 경우 클러스터링되지 않은 테이블에 비해 매우 빠르게 처리될 수 있음

### 8.8.4.3 프라이머리 키는 반드시 명시할 것

- 가능하면 AUTO_INCREMENT 칼럼을 이용해서라도 프라이머리 키는 생성하는 것을 권장
- InnoDB 테이블에서 프라이머리 키를 정의하지 않으면 내부적으로 일련번호 칼럼 추가됌
  - 이는 사용자가 사용 불가능

### AUTO_INCREMENT 칼럼을 인조 식별자로 사용할 경우

- `인조 식별자`: 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키
- 복합으로 프라이머리 키가 만들어지는 경우 프라이머리 키의 크기가 길어질 때
- 세컨더리 인덱스가 필요치 않다면 그대로 프라이머리 키를 사용하는 것이 좋음
- 로그 테이블과 같이 조회보다는 INSERT 위주의 테이블들은 AUTO_INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움