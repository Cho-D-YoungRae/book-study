# Chapter 3. 스프링 부트로 마이크로서비스 구축하기

> 마이크로서비스 개발 기반을 성공적으로 다지려면 다음 세 가지 중요한 역할에서 시작

- 아키텍트
- 소프트웨어 개발자
- 데브옵스

## 3.1 아키텍트 이야기: 마이크로서비스 아키텍처 설계

> 아키텍트의 업무

- 비즈니스 문제 분해
- 서비스 세분화 확정
- 서비스 인터페이스 정의

### 3.1.1 비즈니스 문제 분해

- 아키텍트는 비즈니스 문제를 각 활동 영역을 대표하는 덩어이(부분)로 분해하고 비즈니스 영역의 특정 부분과 연관된 비즈니스 규칙과 데이터 로직을 이 덩어리 안에 은닉
- 비즈니스 문제를 식별하고 마이크로 서비스 후보로 분해하는 데 사용할 수 있는 지침
  - `비즈니스 문제를 기술하는 데 사용된 명사에 주목`: 문제를 기술하는 데 동일한 명사가 반복해서 사용된다면 핵심 비즈니스 영역과 마이크로서비스의 기회를 나타내는 좋은 징후
  - `동사에 주목`:동사는 행동을 강조하고 문제 영역의 윤곽을 자연스럽게 드러냄
  - `데이터 응집성을 찾아라`: 비즈니스 문제를 개별 부분으로 나눌 때 서로 연관성이 높은 데이터 부분을 찾아야 함. 통신 중 갑자기 지금까지 논의한 것과 전혀 다른 데이터를 읽고 업데이트 한다면 또 다른 서비스 후보가 나타났다고 볼 수 있음. 마이크로서비스는 완전히 자기 데이터를 가져야 함

### 3.1.2 서비스 세분화 확정

#### 올바른 세분화 수준에 대한 정답을 구하기 위한 개념

- `마이크로서비스는 광범위하게 시작하고 더 작은 서비스로 리팩터링 하는 것이 좋다`: 마이크로 서비스 여정을 시작할 때는 모든 것을 마이크로서비스로 만들어 버리기 쉽다. 문제 영역을 작은 서비스로 분해하면 마이크로서비스가 단지 작은 데이터 서비스로 전락할 수 있기 때문에 조기에 복잡성을 많이 겪는다.
- `서비스 간 교류하는 방식에 중점을 둔다`: 이것은 문제 도메인(영역)에 대한 큰 단위의 인터페이스를 만드는 데 도움이 된다. 큰 것을 작게 리팩터링 하는 것이 더 쉽다.
- `문제 도메인에 이해가 깊어지면서 서비스 책임도 계속 변한다`: 새로운 애플리케이션 기능이 요구될 때 대개 마이크로서비스가 그 책임을 맡는다. 마이크로서비스는 단일 서비스로 시작하여 여러 서비스로 분화되며 성장하는데, 원래 서비스는 새로운 서비스들을 오케스트레이션하고 애플리케이션의 다른 부분을 캡슐화 하는 역할을 한다.

#### 너무 큰 마이크로서비스의 징후

- `책임이 너무 많은 서비스`: 해당 서비스에서 비즈니스 로직의 일반적 흐름이 복잡하고 지나치게 다양한 종류의 비즈니스 규칙을 시행하는 것 처럼 보임
- `다수 테이블에 걸쳐 데이터를 관리하는 서비스`: 마이크로서비스는 자기가 관리하는 데이터에 대한 기록이다. 여러 테이블에 데이터를 유지하거나 서비스의 데이터베이스 외부에 있는 테이블에 접근한다면 서비스가 너무 크다는 징조다. 필자는 마이크로서비스가 3~5개 이하의 테이블을 소유해야 한다는 지침을 사용하고 싶다. 이보다 더 많다면 서비스가 너무 많은 책임을 담당할 가능성이 높다.
- `테스트가 너무 많은 서비스`: 서비스는 시간이 지남에 따라 규모와 책임이 커질 수 있다. 서비스가 적은 수의 테스트 케이스로 시작해서 수백 개의 유닛 테스트와 통합 테스트로 끝나는 서비스가 있다면 리팩터링이 필요할 수 있다.

#### 너무 작은 마이크로 서비스

- `문제 도메인의 한 부분에 속한 마이크로서비스가 토끼처럼 번식한다`: 모든 것이 마이크로서비스가 되면 서비스에서 비즈니스 로직을 구성하는 것이 복잡하고 어려워진다. 작업을 완료하는 데 필요한 서비스 수가 엄청나게 증가하기 때문이다. 흔한 징후는 애플리케이션에 수십 개의 마이크로서비스가 존재하고 각 서비스가 하나의 데이터베이스 테이블과 통신할 때 나타난다.
- `마이크로서비스가 지나치게 상호 의존적이다`: 문제 영역의 한 부분에 속한 마이크로서비스가 하나의 사용자 요청을 완료하려고 계속 서로 호출하고 있다는 것이 발견된다.
- `마이크로서비스가 단순한 CRUD 서비스 집합이 된다`: 마이크로서비스는 비즈니스 로직의 표현이 데이터 소스의 추상화 계층이 아니다. 마이크로서비스가 CRUD 관련 로직만 수행한다면 너무 세분화된 것일 수 있다.

### 3.1.3 서비스 인터페이스 설계

- `REST 철학을 수용하라`: 이것은 리처드슨의 성숙도 모델과 함께 모범 사례 중 하나다. 서비스에 대한 REST 접근 방식은 표준 HTTP 동사를 사용하면서 서비스 호출 프로토콜로 HTTP 를 수용하는 것이 핵심이다. HTTP 동사를 기반으로 기본 행동 양식을 모델링하라.
- `URI를 사용하여 의도를 전달하라`: 서비스의 엔드포인트로 사용되는 URI는 문제 영역에 존재하는 다양한 자원을 기술하고 자원 관계에 대한 기본 메커니즘을 제공해야 한다.
- `요청과 응답에 JSON을 사용하라`: JSON 은 총 경량 데이터 직렬화 프로토콜이며 XML 보다 훨씬 사용하기 쉽다.
- `HTTP 상태 코드로 결과를 전달하라`: HTTP 프로토콜에 서비스 호출의 성공과 실패를 명시하는 풍부한 표준 응답 코드가 있다. 상태 코드를 익히고 모둔 서비스에 일관되게 사용하는 것이 매우 중요하다.

## 3.2 마이크로서비스를 사용하지 말아야 할 때

- 분산 시스템 구축의 복잡성
  - 조직에서 고도로 분산된 애플리케이션을 성공시키는 데 필요한 자동화와 운영 작업(모니터링, 확장 등)에 기꺼이 투자하지 않는 한 마이크로서비스 사용을 고려하지 않는 편이 좋음
- 가상 서버나 컨테이너 스프롤(sprawl)
  - 대규모 마이크로서비스 기반 애플리케이션에서 구축 및 관리해야 하는 서버나 컨테이너가 많음
  - 클라우드에서 이들 서비스를 실행하는 데 드는 비용이 저렴하더라도 서버를 관리하고 모니터링하는 운영 작업은 엄청나게 복잡할 수 있음
- 애플리케이션 타입
  - 마이크로서비스는 재사용성을 추구하며 고도의 회복성과 확장성이 필요한 대규모 애플리케이션을 구축하는 데 유용
  - 소규모 애플리케이션이나 적은 사용자 기반의 애플리케이션을 만들 때 마이크로서비스와 같은 분산 모델로 구축한다면 연관된 복잡성 때문에 그 가치보다 더 많은 비용이 발생할 수 있음
- 데이터 트랜잭션과 일관성
  - 애플리케이션이 여러 데이터 소스에 걸쳐 복잡한 데이터를 집계하고 변환해야 한다면 마이크로서비스의 분산된 특성으로 인해 이 작업은 어려워짐

## 3.4 데브옵스 이야기: 혹독한 런타임 구축

### 마이크로서비스 개발 원칙

- `마이크로서비스는 일체형(self-contained)이어야 한다`: 하나의 소프트ㅜ에어 산출물로 시작 및 종료할 수 있는 서비스의 여러 인스턴스를 독립적으로 배포할 수 있어야 한다.
- `마이크로서비스는 구성 가능(configurable)해야 한다`: 서비스 인스턴스가 시작하면 필요한 구성 정보를 한 곳에서 읽어 오거나 환경 변수로 전달받아야 한다. 서비스 구성 정보를 설정하는 데 사람의 개입이 없어야 한다.
- `마이크로서비스 인스턴스는 클라이언트에 투명(transparent)해야 한다`: 클라이언트는 서비스의 정확한 위치를 알고 있어서는 안된다. 그 대신 애플리케이션이 마이크로서비스 인스턴스의 물리적 위치를 몰라도 인스턴스 위치를 찾을 수 있도록 마이크로서비스 클라이언트는 서비스 디스커버리 에이전트와 통신해야 한다.
- `마이크로서비스는 자기 상태(health)를 전달해야 한다`: 이는 클라우드 아키텍처에서 매우 중요한 부분이다. 마이크로서비스 인스턴스는 고장 날 수 있으며 디스커버리 에이전트는 고장난 인스턴스를 우회해서 라우팅해야 한다. 이 책에서는 스프링 부트 애궃에이터(actuator)를 사용해서 각 마이크로서비스 상태를 표시한다.

### 위 네 가지 원칙에 매핑되는 운영 수명 주기

- `서비스 조립(service assembly)`: 동일한 서비스 코드와 런타임이 정확히 동일한 방식으로 배포되도록 반복성과 일관성을 보장하면서 서비스를 패키징하고 배포하는 방법이다.
- `서비스 부트스트래핑(service bootstrapping)`: 마이크로서비스를 사람의 개입 없이 모든 환경에서 빠르게 시작하고 배포할 수 있도록 런타임 코드에서 애플리케이션 코드와 환경별 구성 코드를 분리하는 방법이다.
- `서비스 등록 및 디스커버리(service registration/discovery)`: 새 마이크로서비스 인스턴스가 배포될 때 애플리케이션 클라이언트가 새 서비스 인스턴스를 발견할 수 있는 방법이다.
- `서비스 모니터링(service monitoring)`: 마이크로서비스 환경에서 높은 가용성이 요구되므로 한 서비스에 여러 인스턴스를 실행하는 것이 일반적이다. 데브옵스 관점에서 마이크로서비스 인스턴스를 모니터링해야 하며 ㅏㅈㅇ애가 발생한 서비스 인스턴스를 우회해서 라우팅하고 종료되는지 확인해야 한다.